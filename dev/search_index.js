var documenterSearchIndex = {"docs":
[{"location":"Theory/DFP/","page":"DFP","title":"DFP","text":"In the journey of explore how to improve parallelism we need to learn the theory behind how to discretize the equation.","category":"page"},{"location":"API/","page":"Index","title":"Index","text":"","category":"page"},{"location":"about/#Why-did-I-create-this-package?","page":"About","title":"Why did I create this package?","text":"","category":"section"},{"location":"about/","page":"About","title":"About","text":"I am pursuing a Master's degree in Scientific Computing and aim to become proficient in developing numerical methods for solving PDEs. This package is part of my research work, focusing on numerical methods for solving nonlinear Schrödinger equations. Additionally, I am interested in parallelizing these methods using GPUs. This work represents a partially successful attempt to parallelize the solution to the aforementioned problem using GPUs. The idea behind this arose from the need to perform larger simulations in a reasonable amount of time with specialized hardware.","category":"page"},{"location":"Theory/Problem/","page":"Problem","title":"Problem","text":"Let Omega be a Cartesian region in mathbbR^m with m=123. We are interested in get an approximation of the complex field Psi Omega times (0T longrightarrow mathbbC^N satisfying the following system of non linear equations in dimensionless form:","category":"page"},{"location":"Theory/Problem/","page":"Problem","title":"Problem","text":"    i Psi_t = D Delta Psi + mathcalV(mathbfx) odot Psi+mathcalJ(Psi)","category":"page"},{"location":"Theory/Problem/","page":"Problem","title":"Problem","text":"where mathbfx = (x_1cdotsx_m), Psi^2=left( psi_1^2cdotspsi_2^2 right), D=diag(d_i) is a mathbbR^Ntimes N diagonal matrix with positive dispersive coefficients, odot is the Hadamard or element-wise product, F mathbbR^N longrightarrow mathbbR, mathcalV Omega longrightarrow mathbbR^N represents an external trapping potential. Finally, the linear functional mathcalJ mathbbC^N longrightarrow mathbbC^N models the internal atomic Josephson junction, and takes the form mathcalJ(Psi)_n = Gammasum_j=1jneq n^N psi_j, where Gamma is a real coefficient","category":"page"},{"location":"API/API/","page":"Types","title":"Types","text":"CurrentModule = SchrodingerToolkit","category":"page"},{"location":"API/API/","page":"Types","title":"Types","text":"Modules = [SchrodingerToolkit]","category":"page"},{"location":"API/API/#SchrodingerToolkit.AbstractBackend","page":"Types","title":"SchrodingerToolkit.AbstractBackend","text":"Abstract type for our available backends\n\n\n\n\n\n","category":"type"},{"location":"API/API/#SchrodingerToolkit.AbstractRuntimeStats","page":"Types","title":"SchrodingerToolkit.AbstractRuntimeStats","text":"AbstractRuntimeStats{IntType,FloatType,ArrayType}\n\nThis abstract type provides basic tracking for runtime analysis of PDE simulation.\n\nFunctions that you need to implement your own Stats type:\n\nlength(Stats): Current number of taken samples.\nislog(Stats): Returns true if the Stats is logging problem related data.\nislocked(Stats): Returns true if the Stats is locked meaning that you can not modify it. This is used to prevent data corruption after deserialization.\nislog_solver_info(Stats): Returns true if the Stats is logging solver related data.\nislog_system_total_power(Stats): Returns true if the Stats is logging the total power of the system.\nislog_component_update_steps(Stats): Returns true if the Stats is logging the number of times that the components are updated.\ninitialize_stats(::Type{FloatVectorType}, ::Type{IntVectorType},ncomponents,log_freq,time_steps,islog_solver_info::Bool): Initialize the memory underlying Stats type. \nstartup_stats!(Stats,start_power,start_energy): Initialize the power and energy at time step 0. This is usally stored at the last index of the memory.\nupdate_power!(Stats,power,index): Update the power at time step index.\nupdate_energy!(Stats,energy,index): Update the energy at time step index.\nadvance_iteration!(Stats): Move from sample  n  to  n+1.\nserialize(Stats,path): Serialize the Stats type to a file.\ndeserialize(::Type{Stats},path): Deserialize the Stats type from a file. The type here is for dispatching purposes.\nsystem_power(Stats,component_idx,index): Get the power at component_idx in time step index.\nsystem_power(Stats,component_idx): Get the full internal power vector at component_idx.\nsystem_energy(Stats,index): Get the energy at time step index.\nsystem_energy(Stats): Get the full internal energy vector.\nstart_power(Stats): Get the power for all components at time step 0.\nstart_power(Stats,component_idx): Get the power at component_idx at time step 0.\nstart_energy(Stats): Get the energy at time step 0.\nget_solver_time(Stats,index): Get the solver time at time step index.\nget_solver_iterations(Stats,index): Get the solver iterations at time step index.\n\nNote 1: Any attempt to modify the Stats type after it is locked must throw an error or a warning.\n\nNote 2: In general is preferred to use CPU vectors for Stats type and taking care of the conversion to other types when needed. This is because indexing is slow and disallowed in GPU arrays.\n\nNote 3: As an API decision, to reduce boilerplate code is expected that when you intialize any method, then this structure is initialized too. This is because the Stats type is used to store incoming data from the simulation and data types are known at that moment. \n\nOptional functions:\n\nupdate_stats!(Stats,time,PDE,Grid,Mem,ItStop): For iterative solvers\nupdate_stats!(Stats,time,PDE,Grid,Mem): For direct solvers\n\nExamples\n\n\n\n\n\n","category":"type"},{"location":"API/API/#SchrodingerToolkit.AbstractSolverMethod","page":"Types","title":"SchrodingerToolkit.AbstractSolverMethod","text":"AbstractSolverMethod{RealType}\n\nThis is the abstract type for all solver methods. It is parametrized by the type of the real numbers used in the solver.\n\n# How to define a new solver method\nTo define a new solver method, you need to define a new struct that is a subtype of this abstract type. The struct must have the following fields:\n- `Grid`: The grid on which the solver will operate.\n\n# Expected initialization\nThe solver method must be initialized with the following arguments:\n- `config`: The basic configuration of the solver.\n- `grid`: The grid on which the solver will operate.\n\n# Required methods\nThe solver method must implement the following methods:\n- `step!`: Perform a single step of the solver.\n\n# Methods related to statistics\n[TODO]\n\n\n\n\n\n","category":"type"},{"location":"API/API/#SchrodingerToolkit.CPUBackend","page":"Types","title":"SchrodingerToolkit.CPUBackend","text":"This represents a CPU based backend\n\n\n\n\n\n","category":"type"},{"location":"API/API/#SchrodingerToolkit.GPUBackend","page":"Types","title":"SchrodingerToolkit.GPUBackend","text":"This represents a GPU based backend\n\n\n\n\n\n","category":"type"},{"location":"API/API/#SchrodingerToolkit.OffsetAllZero","page":"Types","title":"SchrodingerToolkit.OffsetAllZero","text":"No dimension has the zero offset\n\n\n\n\n\n","category":"type"},{"location":"API/API/#SchrodingerToolkit.OffsetNonZero","page":"Types","title":"SchrodingerToolkit.OffsetNonZero","text":"Every dimension has the zero offset\n\n\n\n\n\n","category":"type"},{"location":"API/API/#SchrodingerToolkit.OffsetUniqueZero","page":"Types","title":"SchrodingerToolkit.OffsetUniqueZero","text":"Only the first dimension has the zero offset\n\n\n\n\n\n","category":"type"},{"location":"API/API/#SchrodingerToolkit.SchrodingerPDE","page":"Types","title":"SchrodingerToolkit.SchrodingerPDE","text":"SchrodingerPDE\n\nThis is an abstract type that represents a Schrodinger PDE. This type is used to define a Schrodinger PDE structure.\n\nParameters:\n\n- `N::Int`: Number of dimensions\n- `RealType`: Type for Real numbers. This is used to define the internal algorithms and data structures.\n\nIs important to note, that the derived structures must handle boundary conditions, initial conditions and important parts of the PDE.\n\n\n\n\n\n","category":"type"},{"location":"API/API/#SchrodingerToolkit.SchrodingerPDEComponent","page":"Types","title":"SchrodingerToolkit.SchrodingerPDEComponent","text":"SchrodingerPDEComponent\n\nThis structure represents a component of the Schrodinger PDE. This is a simple structure that contains the necessary information\nto solve the Schrodinger PDE for a single component.\n\nFields:\n\n- `σ::Tv`: Dispersion coefficient => Must be non negative\n- `f::Fn`: ∂∇F/∂xᵢ(x) = f(x)\n- `ψ::InitialCondition`: Initial condition \n- `V::TrappingPotential`: External trapping potential\n- `Γ::Γv`: Josephson Junction Coefficient => In some documents this coefficient is the same for all components but I guess it can be different under some circumstances.\n\nBy default `V` and `Γ` are set to `nothing` but they can be set to a trapping potential and a Josephson junction coefficient respectively if you want to work with a Gross Pitaevsky PDE.\n\n\n\n\n\n","category":"type"},{"location":"API/API/#SchrodingerToolkit.SchrodingerPDENonPolynomic","page":"Types","title":"SchrodingerToolkit.SchrodingerPDENonPolynomic","text":"SchrodingerPDENonPolynomic\n\nThis structure represents a Schrodinger PDE with non-polynomical potentials.\n\nFields:\n\n- `boundaries::NTuple{N,NTuple{2,Tv}}`: Boundaries of the cartesian domain where you want to solve the PDE.\n- `components::MComp`: Components of the Schrodinger PDE\n- `F::Potential`: Non-polynomical potential\n- `T::Tv`: Final time\n\n\n\n\n\n","category":"type"},{"location":"API/API/#SchrodingerToolkit.SchrodingerPDEPolynomic","page":"Types","title":"SchrodingerToolkit.SchrodingerPDEPolynomic","text":"SchrodingerPDEPolynomic\n\nThis structure represents a Schrodinger PDE with polynomical potentials.\n\nFields:\n\n- `boundaries::NTuple{N,NTuple{2,Tv}}`: Boundaries of the cartesian domain where you want to solve the PDE.\n- `components::MComp`: Components of the Schrodinger PDE\n- `F::Potential`: Polynomical potential\n- `N::Optimized`: Optimized structure for polynomical potentials. Here is stored an auxiliary function without the catastrophic cancellation problem.\n- `T::Tv`: Final time\n\n\n\n\n\n","category":"type"},{"location":"API/API/#SchrodingerToolkit.xPUBackend","page":"Types","title":"SchrodingerToolkit.xPUBackend","text":"This represents a heterogeneous based backend (Can use a mixture of CPU and GPU)\n\n\n\n\n\n","category":"type"},{"location":"API/API/#Base.eltype-Union{Tuple{Type{SchrodingerPDENonPolynomic{N, Tv, MComp, Potential}}}, Tuple{Potential}, Tuple{MComp}, Tuple{Tv}, Tuple{N}} where {N, Tv, MComp, Potential}","page":"Types","title":"Base.eltype","text":"Type of the elements for the Schrodinger PDE\n\n\n\n\n\n","category":"method"},{"location":"API/API/#Base.eltype-Union{Tuple{Type{SchrodingerPDEPolynomic{N, Tv, MComp, Potential, Optimized}}}, Tuple{Optimized}, Tuple{Potential}, Tuple{MComp}, Tuple{Tv}, Tuple{N}} where {N, Tv, MComp, Potential, Optimized}","page":"Types","title":"Base.eltype","text":"Type of the elements for the Schrodinger PDE\n\n\n\n\n\n","category":"method"},{"location":"API/API/#Base.ndims-Union{Tuple{SchrodingerPDENonPolynomic{N, Tv, MComp, Potential}}, Tuple{Potential}, Tuple{MComp}, Tuple{Tv}, Tuple{N}} where {N, Tv, MComp, Potential}","page":"Types","title":"Base.ndims","text":"Number of dimensions for the Schrodinger PDE\n\n\n\n\n\n","category":"method"},{"location":"API/API/#Base.ndims-Union{Tuple{SchrodingerPDEPolynomic{N, Tv, MComp, Potential, Optimized}}, Tuple{Optimized}, Tuple{Potential}, Tuple{MComp}, Tuple{Tv}, Tuple{N}} where {N, Tv, MComp, Potential, Optimized}","page":"Types","title":"Base.ndims","text":"Number of dimensions for the Schrodinger PDE\n\n\n\n\n\n","category":"method"},{"location":"API/API/#SchrodingerToolkit.advance_iteration!-Union{Tuple{SchrodingerToolkit.RuntimeStats{IntType, FloatType, IntVectorType, FloatVectorType, Power} where {IntVectorType, FloatVectorType<:(AbstractArray{FloatType}), Power<:Tuple{Vararg{SchrodingerToolkit.ComponentPower{FloatType, FloatVectorType}}}}}, Tuple{FloatType}, Tuple{IntType}} where {IntType<:Integer, FloatType<:AbstractFloat}","page":"Types","title":"SchrodingerToolkit.advance_iteration!","text":"advance_iteration!(R::RuntimeStats{IntType,FloatType}) where {IntType<:Integer,\n                                                             FloatType<:AbstractFloat}\n\nAdvance the iteration in the stats structure.\n\n\n\n\n\n","category":"method"},{"location":"API/API/#SchrodingerToolkit.calculate_diff_system_energy-Tuple{Stats} where Stats<:SchrodingerToolkit.RuntimeStats","page":"Types","title":"SchrodingerToolkit.calculate_diff_system_energy","text":"calculate_diff_system_energy(stats)\n\nCalculate the absolute value of the difference between the system energy and the energy at time step 0.\n\nArguments\n\nstats::Stats: The stats structure.\n\n\n\n\n\n","category":"method"},{"location":"API/API/#SchrodingerToolkit.calculate_diff_system_power-Union{Tuple{Stats}, Tuple{Stats, Any}} where Stats<:SchrodingerToolkit.RuntimeStats","page":"Types","title":"SchrodingerToolkit.calculate_diff_system_power","text":"calculate_diff_system_power(stats)\n\nCalculate the absolute value of the difference between the system power and the power at time step 0.\n\nArguments\n\nstats::Stats: The stats structure.\n\n\n\n\n\n","category":"method"},{"location":"API/API/#SchrodingerToolkit.calculate_diff_system_total_power-Tuple{Stats} where Stats<:SchrodingerToolkit.RuntimeStats","page":"Types","title":"SchrodingerToolkit.calculate_diff_system_total_power","text":"calculate_diff_system_total_power(stats)\n\nCalculate the absolute value of the difference between the system total power and the total power at time step 0.\n\nArguments\n\nstats::Stats: The stats structure.\n\n\n\n\n\n","category":"method"},{"location":"API/API/#SchrodingerToolkit.estimate_timesteps-Union{Tuple{PGrid}, Tuple{SPDE}, Tuple{SPDE, PGrid}} where {SPDE<:SchrodingerPDE, PGrid<:PeriodicGrid}","page":"Types","title":"SchrodingerToolkit.estimate_timesteps","text":"Estimate the number of timesteps for the Schrodinger PDE\n\n\n\n\n\n","category":"method"},{"location":"API/API/#SchrodingerToolkit.evaluate_ψ!-Union{Tuple{PGrid}, Tuple{SPDE}, Tuple{SPDE, PGrid, Any}} where {SPDE<:SchrodingerPDE, PGrid<:PeriodicGrid}","page":"Types","title":"SchrodingerToolkit.evaluate_ψ!","text":"Evaluation of the initial condition for the Schrodinger PDE where the output is stored in Container\n\n\n\n\n\n","category":"method"},{"location":"API/API/#SchrodingerToolkit.evaluate_ψ-Union{Tuple{PGrid}, Tuple{Optimized}, Tuple{Potential}, Tuple{MComp}, Tuple{Tv}, Tuple{N}, Tuple{SchrodingerPDEPolynomic{N, Tv, MComp, Potential, Optimized}, PGrid, Any}} where {N, Tv, MComp, Potential, Optimized, PGrid<:PeriodicGrid}","page":"Types","title":"SchrodingerToolkit.evaluate_ψ","text":"Evaluation of the initial condition for the Schrodinger PDE\n\n\n\n\n\n","category":"method"},{"location":"API/API/#SchrodingerToolkit.evaluate_ψ-Union{Tuple{PGrid}, Tuple{Potential}, Tuple{MComp}, Tuple{Tv}, Tuple{N}, Tuple{SchrodingerPDENonPolynomic{N, Tv, MComp, Potential}, PGrid, Any}} where {N, Tv, MComp, Potential, PGrid<:PeriodicGrid}","page":"Types","title":"SchrodingerToolkit.evaluate_ψ","text":"Evaluation of the initial condition for the Schrodinger PDE\n\n\n\n\n\n","category":"method"},{"location":"API/API/#SchrodingerToolkit.get_V-Union{Tuple{Optimized}, Tuple{Potential}, Tuple{MComp}, Tuple{Tv}, Tuple{N}, Tuple{SchrodingerPDEPolynomic{N, Tv, MComp, Potential, Optimized}, Int64}} where {N, Tv, MComp, Potential, Optimized}","page":"Types","title":"SchrodingerToolkit.get_V","text":"Trapping potential for the i-th Schrodinger PDE component\n\n\n\n\n\n","category":"method"},{"location":"API/API/#SchrodingerToolkit.get_V-Union{Tuple{Potential}, Tuple{MComp}, Tuple{Tv}, Tuple{N}, Tuple{SchrodingerPDENonPolynomic{N, Tv, MComp, Potential}, Int64}} where {N, Tv, MComp, Potential}","page":"Types","title":"SchrodingerToolkit.get_V","text":"Trapping potential for the i-th Schrodinger PDE component\n\n\n\n\n\n","category":"method"},{"location":"API/API/#SchrodingerToolkit.get_boundary-Union{Tuple{Optimized}, Tuple{Potential}, Tuple{MComp}, Tuple{Tv}, Tuple{N}, Tuple{SchrodingerPDEPolynomic{N, Tv, MComp, Potential, Optimized}, Int64}} where {N, Tv, MComp, Potential, Optimized}","page":"Types","title":"SchrodingerToolkit.get_boundary","text":"Boundary start and end point at index dimension\n\n\n\n\n\n","category":"method"},{"location":"API/API/#SchrodingerToolkit.get_boundary-Union{Tuple{Potential}, Tuple{MComp}, Tuple{Tv}, Tuple{N}, Tuple{SchrodingerPDENonPolynomic{N, Tv, MComp, Potential}, Int64}} where {N, Tv, MComp, Potential}","page":"Types","title":"SchrodingerToolkit.get_boundary","text":"Boundary start and end point at index dimension\n\n\n\n\n\n","category":"method"},{"location":"API/API/#SchrodingerToolkit.get_component-Union{Tuple{Optimized}, Tuple{Potential}, Tuple{MComp}, Tuple{Tv}, Tuple{N}, Tuple{SchrodingerPDEPolynomic{N, Tv, MComp, Potential, Optimized}, Int64}} where {N, Tv, MComp, Potential, Optimized}","page":"Types","title":"SchrodingerToolkit.get_component","text":"Obtain the component of the Schrodinger PDE at index\n\n\n\n\n\n","category":"method"},{"location":"API/API/#SchrodingerToolkit.get_component-Union{Tuple{Potential}, Tuple{MComp}, Tuple{Tv}, Tuple{N}, Tuple{SchrodingerPDENonPolynomic{N, Tv, MComp, Potential}, Int64}} where {N, Tv, MComp, Potential}","page":"Types","title":"SchrodingerToolkit.get_component","text":"Obtain the component of the Schrodinger PDE at index\n\n\n\n\n\n","category":"method"},{"location":"API/API/#SchrodingerToolkit.get_f-Union{Tuple{Optimized}, Tuple{Potential}, Tuple{MComp}, Tuple{Tv}, Tuple{N}, Tuple{SchrodingerPDEPolynomic{N, Tv, MComp, Potential, Optimized}, Int64}} where {N, Tv, MComp, Potential, Optimized}","page":"Types","title":"SchrodingerToolkit.get_f","text":"Function for the Schrodinger PDE component\n\n\n\n\n\n","category":"method"},{"location":"API/API/#SchrodingerToolkit.get_f-Union{Tuple{Potential}, Tuple{MComp}, Tuple{Tv}, Tuple{N}, Tuple{SchrodingerPDENonPolynomic{N, Tv, MComp, Potential}, Int64}} where {N, Tv, MComp, Potential}","page":"Types","title":"SchrodingerToolkit.get_f","text":"Function for the Schrodinger PDE component\n\n\n\n\n\n","category":"method"},{"location":"API/API/#SchrodingerToolkit.get_field-Union{Tuple{SchrodingerPDENonPolynomic{N, Tv, MComp, Potential}}, Tuple{Potential}, Tuple{MComp}, Tuple{Tv}, Tuple{N}} where {N, Tv, MComp, Potential}","page":"Types","title":"SchrodingerToolkit.get_field","text":"Potential for the Schrodinger PDE\n\n\n\n\n\n","category":"method"},{"location":"API/API/#SchrodingerToolkit.get_field-Union{Tuple{SchrodingerPDEPolynomic{N, Tv, MComp, Potential, Optimized}}, Tuple{Optimized}, Tuple{Potential}, Tuple{MComp}, Tuple{Tv}, Tuple{N}} where {N, Tv, MComp, Potential, Optimized}","page":"Types","title":"SchrodingerToolkit.get_field","text":"Potential for the Schrodinger PDE\n\n\n\n\n\n","category":"method"},{"location":"API/API/#SchrodingerToolkit.get_optimized-Union{Tuple{SchrodingerPDENonPolynomic{N, Tv, MComp, Potential}}, Tuple{Potential}, Tuple{MComp}, Tuple{Tv}, Tuple{N}} where {N, Tv, MComp, Potential}","page":"Types","title":"SchrodingerToolkit.get_optimized","text":"Non polynomial potentials can't be optimized so return nothing\n\n\n\n\n\n","category":"method"},{"location":"API/API/#SchrodingerToolkit.get_optimized-Union{Tuple{SchrodingerPDEPolynomic{N, Tv, MComp, Potential, Optimized}}, Tuple{Optimized}, Tuple{Potential}, Tuple{MComp}, Tuple{Tv}, Tuple{N}} where {N, Tv, MComp, Potential, Optimized}","page":"Types","title":"SchrodingerToolkit.get_optimized","text":"Simplified polynomial to evade catastrophic cancellation\n\n\n\n\n\n","category":"method"},{"location":"API/API/#SchrodingerToolkit.get_time_boundary-Union{Tuple{SchrodingerPDENonPolynomic{N, Tv, MComp, Potential}}, Tuple{Potential}, Tuple{MComp}, Tuple{Tv}, Tuple{N}} where {N, Tv, MComp, Potential}","page":"Types","title":"SchrodingerToolkit.get_time_boundary","text":"Finish time for the Schrodinger PDE\n\n\n\n\n\n","category":"method"},{"location":"API/API/#SchrodingerToolkit.get_time_boundary-Union{Tuple{SchrodingerPDEPolynomic{N, Tv, MComp, Potential, Optimized}}, Tuple{Optimized}, Tuple{Potential}, Tuple{MComp}, Tuple{Tv}, Tuple{N}} where {N, Tv, MComp, Potential, Optimized}","page":"Types","title":"SchrodingerToolkit.get_time_boundary","text":"Finish time for the Schrodinger PDE\n\n\n\n\n\n","category":"method"},{"location":"API/API/#SchrodingerToolkit.get_Γ-Union{Tuple{Optimized}, Tuple{Potential}, Tuple{MComp}, Tuple{Tv}, Tuple{N}, Tuple{SchrodingerPDEPolynomic{N, Tv, MComp, Potential, Optimized}, Int64}} where {N, Tv, MComp, Potential, Optimized}","page":"Types","title":"SchrodingerToolkit.get_Γ","text":"Josephson Junction Coefficient for the i-th Schrodinger PDE component\n\n\n\n\n\n","category":"method"},{"location":"API/API/#SchrodingerToolkit.get_Γ-Union{Tuple{Potential}, Tuple{MComp}, Tuple{Tv}, Tuple{N}, Tuple{SchrodingerPDENonPolynomic{N, Tv, MComp, Potential}, Int64}} where {N, Tv, MComp, Potential}","page":"Types","title":"SchrodingerToolkit.get_Γ","text":"Josephson Junction Coefficient for the i-th Schrodinger PDE component\n\n\n\n\n\n","category":"method"},{"location":"API/API/#SchrodingerToolkit.get_σ-Union{Tuple{Optimized}, Tuple{Potential}, Tuple{MComp}, Tuple{Tv}, Tuple{N}, Tuple{SchrodingerPDEPolynomic{N, Tv, MComp, Potential, Optimized}, Int64}} where {N, Tv, MComp, Potential, Optimized}","page":"Types","title":"SchrodingerToolkit.get_σ","text":"Dispersion coefficient for the Schrodinger PDE component at index\n\n\n\n\n\n","category":"method"},{"location":"API/API/#SchrodingerToolkit.get_σ-Union{Tuple{Potential}, Tuple{MComp}, Tuple{Tv}, Tuple{N}, Tuple{SchrodingerPDENonPolynomic{N, Tv, MComp, Potential}, Int64}} where {N, Tv, MComp, Potential}","page":"Types","title":"SchrodingerToolkit.get_σ","text":"Dispersion coefficient for the Schrodinger PDE component at index\n\n\n\n\n\n","category":"method"},{"location":"API/API/#SchrodingerToolkit.get_ψ-Union{Tuple{Optimized}, Tuple{Potential}, Tuple{MComp}, Tuple{Tv}, Tuple{N}, Tuple{SchrodingerPDEPolynomic{N, Tv, MComp, Potential, Optimized}, Int64}} where {N, Tv, MComp, Potential, Optimized}","page":"Types","title":"SchrodingerToolkit.get_ψ","text":"Initial condition for the Schrodinger PDE component\n\n\n\n\n\n","category":"method"},{"location":"API/API/#SchrodingerToolkit.get_ψ-Union{Tuple{Potential}, Tuple{MComp}, Tuple{Tv}, Tuple{N}, Tuple{SchrodingerPDENonPolynomic{N, Tv, MComp, Potential}, Int64}} where {N, Tv, MComp, Potential}","page":"Types","title":"SchrodingerToolkit.get_ψ","text":"Initial condition for the Schrodinger PDE component\n\n\n\n\n\n","category":"method"},{"location":"API/API/#SchrodingerToolkit.initialize_stats-Union{Tuple{FloatVectorType}, Tuple{IntVectorType}, Tuple{IntType}, Tuple{Type{FloatVectorType}, Type{IntVectorType}, IntType, IntType, IntType}} where {IntType, IntVectorType, FloatVectorType}","page":"Types","title":"SchrodingerToolkit.initialize_stats","text":"initialize_stats(FloatVectorType, IntVectorType, ncomponents, log_freq, time_steps;\n                 log_stats = true, log_solver_info = true,\n                 log_component_update_steps = false,\n                 log_system_total_power = false, islocked = false)\n\nInitialize the stats structure.\n\nArguments\n\nFloatVectorType: The type of the floating point vector.\nIntVectorType: The type of the integer vector.\nncomponents: The number of components.\nlog_freq: The frequency to log the stats.\ntime_steps: The total number of time steps.\n\nOptional arguments\n\nlog_stats: Log the stats.\nlog_solver_info: Log the solver information.\nlog_component_update_steps: Log the component update steps.\nlog_system_total_power: Log the system total power.\nislocked: Lock the stats.\n\nReturns\n\nRuntimeStats: The stats structure.\n\n\n\n\n\n","category":"method"},{"location":"API/API/#SchrodingerToolkit.iscpu","page":"Types","title":"SchrodingerToolkit.iscpu","text":"Function to check if a backend is a CPU based backend\n\n\n\n\n\n","category":"function"},{"location":"API/API/#SchrodingerToolkit.isgpu","page":"Types","title":"SchrodingerToolkit.isgpu","text":"Function to check if a backend is a GPU based backend\n\n\n\n\n\n","category":"function"},{"location":"API/API/#SchrodingerToolkit.islocked-Tuple{SchrodingerToolkit.RuntimeStats}","page":"Types","title":"SchrodingerToolkit.islocked","text":"islocked(R::RuntimeStats)\n\nCheck if the stats are locked. This is used to check if the stats are locked and cannot be modified in any way.\n\nNote\n\nAny attempt to use or modify the Stats structure if it is locked will throw an error.\n\n\n\n\n\n","category":"method"},{"location":"API/API/#SchrodingerToolkit.islog-Tuple{SchrodingerToolkit.RuntimeStats}","page":"Types","title":"SchrodingerToolkit.islog","text":"islog(R::RuntimeStats)\n\nCheck if the stats are being logged. Note that this is different from isregistering_stats. This is used to check if the stats are being logged at the current time step.\n\n\n\n\n\n","category":"method"},{"location":"API/API/#SchrodingerToolkit.isregistering_stats-Tuple{SchrodingerToolkit.RuntimeStats}","page":"Types","title":"SchrodingerToolkit.isregistering_stats","text":"isregistering_stats(R::RuntimeStats)\n\nCheck if the stats are being registered.\n\n\n\n\n\n","category":"method"},{"location":"API/API/#SchrodingerToolkit.isxpu","page":"Types","title":"SchrodingerToolkit.isxpu","text":"Function to check if a backend is a heterogeneous based backend\n\n\n\n\n\n","category":"function"},{"location":"API/API/#SchrodingerToolkit.junction!-Union{Tuple{PDEeq}, Tuple{PDEeq, Any, Any, Any}} where PDEeq<:SchrodingerPDE","page":"Types","title":"SchrodingerToolkit.junction!","text":"junction!(SPDE::PDEeq, memory, output)\n\nCheck if the Schrodinger PDE has a Josephson Junction and return the sum of the current state if it has one.\n\n\n\n\n\n","category":"method"},{"location":"API/API/#SchrodingerToolkit.matrix_to_vector-Union{Tuple{Type{M}}, Tuple{M}} where M<:(DenseMatrix)","page":"Types","title":"SchrodingerToolkit.matrix_to_vector","text":"S = matrix_to_vector(M)\n\nReturn the dense vector storage type S related to the dense matrix storage type M.\n\n\n\n\n\n","category":"method"},{"location":"API/API/#SchrodingerToolkit.measure-Union{Tuple{PeriodicGrid{V, T, R, N}}, Tuple{N}, Tuple{R}, Tuple{T}, Tuple{V}} where {V<:Integer, T<:Real, R<:AbstractRange{T}, N}","page":"Types","title":"SchrodingerToolkit.measure","text":"measure(A::PeriodicGrid{V,T,R,N}) where {V<:Integer,T<:Real,R<:AbstractRange{T},N}\n\nReturn the measure of the grid.\n\n\n\n\n\n","category":"method"},{"location":"API/API/#SchrodingerToolkit.ncomponents-Tuple{PDEeq} where PDEeq<:SchrodingerPDE","page":"Types","title":"SchrodingerToolkit.ncomponents","text":"Number of components for the Schrodinger PDE\n\n\n\n\n\n","category":"method"},{"location":"API/API/#SchrodingerToolkit.startup_stats!-Union{Tuple{Stats}, Tuple{Stats, Any, Any, Any}} where Stats<:SchrodingerToolkit.RuntimeStats","page":"Types","title":"SchrodingerToolkit.startup_stats!","text":"startup_stats!(stats::Stats, start_power, start_energy, total_power)\n\nInitialize the stats structure with the power, energy and total power at time step 0.\n\n\n\n\n\n","category":"method"},{"location":"API/API/#SchrodingerToolkit.startup_stats!-Union{Tuple{Stats}, Tuple{Stats, Any, Any}} where Stats<:SchrodingerToolkit.RuntimeStats","page":"Types","title":"SchrodingerToolkit.startup_stats!","text":"startup_stats!(stats::Stats, start_power, start_energy)\n\nInitialize the stats structure with the power and energy at time step 0.\n\n\n\n\n\n","category":"method"},{"location":"API/API/#SchrodingerToolkit.step!","page":"Types","title":"SchrodingerToolkit.step!","text":"With this function you can advance one step in time.\n\n    The implementation of this function is mandatory.\n\n    From the user perspective, this function should be called to advance the solution one step in time.\n\n    The expected parameters are:\n        - `method`: The method to be used to advance the solution.\n        - `memory`: The memory of the method.\n            Expectations about memory are: \n                - The memory must be allocated by the method at initialization.\n                - The memory must be updated by the method.\n                - You must provide a method called `current_state!(memory)` that allows the caller to a reference to the current state (time step).\n                - You must provide a method called `current_state(memory)` that allows the caller to get a copy of the current state of (time step).\n        - `stats`: The statistics of the method.\n                - If you want to log statistics and you perform some kind of component wise operation then:\n                    - You must call `update_solver_info!(stats, time, niter)` to store every time spent at linear solvers.\n                - In general \n        - `PDE`: The PDE to be solved.\n        - `config`: The configuration of the solver.\n    \n    Here dispatch is used to call the correct version of step!.\n\n    The return of this function must be the time taken to advance one step in time.\n\n\n\n\n\n","category":"function"},{"location":"API/API/#SchrodingerToolkit.test_if_zero","page":"Types","title":"SchrodingerToolkit.test_if_zero","text":"v = test_if_zero(V,idx)\n\nReturn true if the element at position idx of the vector V is zero.\n\n\n\n\n\n","category":"function"},{"location":"API/API/#SchrodingerToolkit.update_component!","page":"Types","title":"SchrodingerToolkit.update_component!","text":"With this function you can update a component of the problem.\n\n    The implementation of this function is suggested but not mandatory.\n\n\n\n\n\n","category":"function"},{"location":"API/API/#SchrodingerToolkit.update_component_update_steps!-Union{Tuple{Stats}, Tuple{Stats, Any}} where Stats<:SchrodingerToolkit.RuntimeStats","page":"Types","title":"SchrodingerToolkit.update_component_update_steps!","text":"update_component_update_steps!(stats, steps)\n\nUpdate the component update steps in the stats structure.\n\nArguments\n\nstats::Stats: The stats structure.\nsteps::IntType: The number of steps performed in the component update.\n\n\n\n\n\n","category":"method"},{"location":"API/API/#SchrodingerToolkit.update_power!-Union{Tuple{Stats}, Tuple{FloatType}, Tuple{IntType}, Tuple{Stats, Any, IntType}} where {IntType<:Integer, FloatType<:AbstractFloat, Stats<:(SchrodingerToolkit.RuntimeStats{IntType, FloatType, IntVectorType, FloatVectorType, Power} where {IntVectorType, FloatVectorType<:(AbstractArray{FloatType}), Power<:Tuple{Vararg{SchrodingerToolkit.ComponentPower{FloatType, FloatVectorType}}}})}","page":"Types","title":"SchrodingerToolkit.update_power!","text":"update_power!(stats, power, idx)\n\nUpdate the power per component in the stats structure.\n\nArguments\n\nstats::Stats: The stats structure.\npower::Vector{FloatType}: The power per component.\nidx::IntType: The index to update.\n\n\n\n\n\n","category":"method"},{"location":"API/API/#SchrodingerToolkit.update_solver_info!-Union{Tuple{Stats}, Tuple{Stats, Any, Any}} where Stats<:SchrodingerToolkit.RuntimeStats","page":"Types","title":"SchrodingerToolkit.update_solver_info!","text":"update_solver_info!(stats, time, iterations)\n\nUpdate the linear solver information in the stats structure.\n\nArguments\n\nstats::Stats: The stats structure.\ntime::FloatType: The time spent in the solver.\niterations::IntType: The number of iterations performed in the solver.\n\n\n\n\n\n","category":"method"},{"location":"API/API/#SchrodingerToolkit.update_stats!-Union{Tuple{Stats}, Tuple{Stats, Any, Any, Any}} where Stats<:SchrodingerToolkit.RuntimeStats","page":"Types","title":"SchrodingerToolkit.update_stats!","text":"update_stats!(stats, step_time, power_per_component, sys_energy)\n\nUpdate the stats structure with the current time, power per component and system energy.\n\nArguments\n\nstats::Stats: The stats structure.\nstep_time::FloatType: Amount of time spent in the current step.\npower_per_component: The power per component.\nsys_energy::FloatType: The system energy.\n\n\n\n\n\n","category":"method"},{"location":"API/API/#SchrodingerToolkit.update_stats!-Union{Tuple{Stats}, Tuple{Stats, Vararg{Any, 4}}} where Stats<:SchrodingerToolkit.RuntimeStats","page":"Types","title":"SchrodingerToolkit.update_stats!","text":"update_stats!(stats, memory, grid, PDE, work_timer)\n\nUpdate the stats structure with the current time, power per component, system energy and total power.\n\nArguments\n\nstats::Stats: The stats structure.\nmemory: The memory structure.\ngrid: The grid structure.\nPDE: The PDE structure.\nwork_timer: The timer for the work done in the current step.\n\nSide effects\n\nAdvances the iteration in the stats structure no matter if the stats are being logged or not. \n\nThis is to keep the stats structure consistent with the simulation.  For that reason is important to call this function at the end of the simulation step.\n\n\n\n\n\n","category":"method"},{"location":"API/API/#SchrodingerToolkit.update_system_energy!-Union{Tuple{Stats}, Tuple{FloatType}, Tuple{IntType}, Tuple{Stats, FloatType, IntType}} where {IntType<:Integer, FloatType<:AbstractFloat, Stats<:(SchrodingerToolkit.RuntimeStats{IntType, FloatType, IntVectorType, FloatVectorType, Power} where {IntVectorType, FloatVectorType<:(AbstractArray{FloatType}), Power<:Tuple{Vararg{SchrodingerToolkit.ComponentPower{FloatType, FloatVectorType}}}})}","page":"Types","title":"SchrodingerToolkit.update_system_energy!","text":"update_system_energy!(stats, energy, idx)\n\nUpdate the system energy in the stats structure.\n\nArguments\n\nstats::Stats: The stats structure.\nenergy::FloatType: The energy.\nidx::IntType: The index to update.\n\n\n\n\n\n","category":"method"},{"location":"API/API/#SchrodingerToolkit.update_system_total_power!-Union{Tuple{Stats}, Tuple{FloatType}, Tuple{IntType}, Tuple{Stats, FloatType, IntType}} where {IntType<:Integer, FloatType<:AbstractFloat, Stats<:(SchrodingerToolkit.RuntimeStats{IntType, FloatType, IntVectorType, FloatVectorType, Power} where {IntVectorType, FloatVectorType<:(AbstractArray{FloatType}), Power<:Tuple{Vararg{SchrodingerToolkit.ComponentPower{FloatType, FloatVectorType}}}})}","page":"Types","title":"SchrodingerToolkit.update_system_total_power!","text":"update_system_total_power!(stats, total_power, idx)\n\nUpdate the system total power in the stats structure.\n\nArguments\n\nstats::Stats: The stats structure.\ntotal_power::FloatType: The total power.\nidx::IntType: The index to update.\n\n\n\n\n\n","category":"method"},{"location":"API/API/#SchrodingerToolkit.vcanonical","page":"Types","title":"SchrodingerToolkit.vcanonical","text":"v = vcanonical(S, n, idx)\n\nCreate a vector of storage type S of length n where the position idx is one and any other position is zero.\n\n\n\n\n\n","category":"function"},{"location":"API/API/#SchrodingerToolkit.vfirst","page":"Types","title":"SchrodingerToolkit.vfirst","text":"v = vfirst(V)\n\nReturn the first element of the vector V.\n\n\n\n\n\n","category":"function"},{"location":"API/API/#SchrodingerToolkit.vlast","page":"Types","title":"SchrodingerToolkit.vlast","text":"v = vlast(V)\n\nReturn the last element of the vector V.\n\n\n\n\n\n","category":"function"},{"location":"API/API/#SchrodingerToolkit.vones-Tuple{Any, Any}","page":"Types","title":"SchrodingerToolkit.vones","text":"v = vones(S, n)\n\nCreate a vector of storage type S of length n only composed of one.\n\n\n\n\n\n","category":"method"},{"location":"API/API/#SchrodingerToolkit.vseq-Tuple{Any, Any}","page":"Types","title":"SchrodingerToolkit.vseq","text":"v = vseq(S, n)\n\nCreate a vector of storage type S of length n where the position i is i.\n\n\n\n\n\n","category":"method"},{"location":"API/API/#SchrodingerToolkit.vundef-Tuple{Any, Any}","page":"Types","title":"SchrodingerToolkit.vundef","text":"v = vundef(S, n)\n\nCreate an uninitialized vector of storage type S of length n.\n\n\n\n\n\n","category":"method"},{"location":"API/API/#SchrodingerToolkit.vzeros-Tuple{Any, Any}","page":"Types","title":"SchrodingerToolkit.vzeros","text":"v = vzeros(S, n)\n\nCreate a vector of storage type S of length n only composed of zero.\n\n\n\n\n\n","category":"method"},{"location":"#[SchrodingerToolkit](https://github.com/walexaindre/SchrodingerToolkit.jl)","page":"Package Overview","title":"SchrodingerToolkit","text":"","category":"section"},{"location":"","page":"Package Overview","title":"Package Overview","text":"This package is designed to solve and develop algorithms for solving certain classes of coupled nonlinear Schrödinger partial differential equations (PDEs). Specifically, we are focused on addressing the following general problem in dimensionless form:","category":"page"},{"location":"","page":"Package Overview","title":"Package Overview","text":"    i Psi_t = -D Delta Psi + mathcalV(mathbfx) odot Psi+ nabla F(Psi^2) odot Psi + mathcalJ(Psi)","category":"page"},{"location":"","page":"Package Overview","title":"Package Overview","text":"Where: ","category":"page"},{"location":"","page":"Package Overview","title":"Package Overview","text":"The expected domain of the problem is a bounded cartesian domain Omega from mathbbR^d with d=123.\nThe boundary conditions are periodic.\nmathbfx is a vector in the space domain of the problem. Where mathbfx = (x_1 x_2 ldots x_d).\nPsi Omega times (0T longrightarrow mathbbC^N with Psi = (psi_1 psi_2 ldots psi_N) is a complex vector of size N. Here, N is the number of components of the system with N1.\nPsi^2 = (psi_1^2psi_2^2dotspsi_n^2 ) represents the vector formed by the squared norm of each component of Psi.\nD= diag(d_i) is a mathbbR^Ntimes N diagonal matrix with positive dispersive coefficients.\nmathcalVmathbbOmega longrightarrow mathbbR^N is an external trapping potential.\nodot denotes the Hadamard product.\nFmathbbR^N longrightarrow mathbbR is a function which models the strength of intra- and inter-species interactions.\nmathcalJmathbbC^N longrightarrow mathbbC^N models the internal Josephson junction. This Josephson junction takes the form mathcalJ(Psi)_n= Gamma displaystylesum_jneq n^N psi_j where Gamma is a real coefficient. ","category":"page"},{"location":"#What-can-you-expect-from-this-package?","page":"Package Overview","title":"What can you expect from this package?","text":"","category":"section"},{"location":"","page":"Package Overview","title":"Package Overview","text":"This package is designed to solve the aforementioned problem using a variety of numerical methods. It is modular, allowing users to easily swap out different components of the solution. Additionally, the package is extensible, enabling users to add new numerical methods with ease.","category":"page"},{"location":"#Important-usage-considerations","page":"Package Overview","title":"Important usage considerations","text":"","category":"section"},{"location":"","page":"Package Overview","title":"Package Overview","text":"This package is designed as a research tool. As such, it may not be as fast or as stable as other packages. However, it is intended to be flexible and easy to use, allowing users to quickly prototype new algorithms and test new ideas.","category":"page"},{"location":"#References","page":"Package Overview","title":"References","text":"","category":"section"},{"location":"","page":"Package Overview","title":"Package Overview","text":"For more information about the methods used here you can check the following references:","category":"page"},{"location":"","page":"Package Overview","title":"Package Overview","text":"A conservative splitting high-order finite difference method for coupled Gross–Pitaevskii equations in 2D\nFinite-difference conservative method for a class of non linear Schrödinger systems\nFinite-difference solutions of a non-linear Schrödinger equation\nStructure preserving Field directional splitting difference methods for nonlinear Schrödinger systems\nCompact finite difference schemes with spectral-like resolution","category":"page"}]
}
