var documenterSearchIndex = {"docs":
[{"location":"Usage/construction/#How-to-define-a-problem","page":"How to define a problem","title":"How to define a problem","text":"","category":"section"},{"location":"Usage/construction/","page":"How to define a problem","title":"How to define a problem","text":"To construct your system, you simply need to define the following functions and structures:","category":"page"},{"location":"Usage/construction/#SchrodingerPDEComponent:-Define-independently-all-the-components-of-the-Schrodinger-equation.","page":"How to define a problem","title":"SchrodingerPDEComponent: Define independently all the components of the Schrodinger equation.","text":"","category":"section"},{"location":"Usage/construction/","page":"How to define a problem","title":"How to define a problem","text":"","category":"page"},{"location":"Usage/construction/","page":"How to define a problem","title":"How to define a problem","text":"SchrodingerPDEComponent","category":"page"},{"location":"Usage/construction/#SchrodingerToolkit.SchrodingerPDEComponent-Usage-construction","page":"How to define a problem","title":"SchrodingerToolkit.SchrodingerPDEComponent","text":"SchrodingerPDEComponent\n\nThis structure represents a component of the Schrodinger PDE. This is a simple structure that contains the necessary information to solve the Schrodinger PDE for a single component.\n\nFields:\n\nσ::Tv: Dispersion coefficient => Must be non negative\nf::Fn: ∂∇F/∂xᵢ(x) = f(x)\nψ::InitialCondition: Initial condition \nV::TrappingPotential: External trapping potential\nΓ::Γv: Josephson Junction Coefficient => In some documents this coefficient is the same for all components but I guess it can be different under some circumstances.\n\nBy default V and Γ are set to nothing but they can be set to a trapping potential and a Josephson junction coefficient respectively if you want to work with a Gross Pitaevsky PDE.\n\n\n\n\n\n","category":"type"},{"location":"Usage/construction/#SchrodingerPDE:-Define-the-Schrodinger-equation-as-a-whole.","page":"How to define a problem","title":"SchrodingerPDE: Define the Schrodinger equation as a whole.","text":"","category":"section"},{"location":"Usage/construction/#If-your-potential-is-polynomial-then-you-need-to-use-SchrodingerPDEPolynomial.","page":"How to define a problem","title":"If your potential is polynomial then you need to use SchrodingerPDEPolynomial.","text":"","category":"section"},{"location":"Usage/construction/","page":"How to define a problem","title":"How to define a problem","text":"SchrodingerPDEPolynomial","category":"page"},{"location":"Usage/construction/#SchrodingerToolkit.SchrodingerPDEPolynomial-Usage-construction","page":"How to define a problem","title":"SchrodingerToolkit.SchrodingerPDEPolynomial","text":"SchrodingerPDEPolynomial\n\nThis structure represents a Schrodinger PDE with polynomical potentials.\n\nFields:\n\nboundaries::NTuple{N,NTuple{2,Tv}}: Boundaries of the cartesian domain where you want to solve the PDE.\ncomponents::MComp: Components of the Schrodinger PDE\nF::Potential: Polynomical potential\nN::Optimized: Optimized structure for polynomical potentials. Here is stored an auxiliary function without the catastrophic cancellation problem.\nT::Tv: Final time\n\n\n\n\n\n","category":"type"},{"location":"Usage/construction/#If-your-potential-is-not-polynomial-then-you-need-to-use-SchrodingerPDENonPolynomial.","page":"How to define a problem","title":"If your potential is not polynomial then you need to use SchrodingerPDENonPolynomial.","text":"","category":"section"},{"location":"Usage/construction/","page":"How to define a problem","title":"How to define a problem","text":"SchrodingerPDENonPolynomial","category":"page"},{"location":"Usage/construction/#SchrodingerToolkit.SchrodingerPDENonPolynomial-Usage-construction","page":"How to define a problem","title":"SchrodingerToolkit.SchrodingerPDENonPolynomial","text":"SchrodingerPDENonPolynomial\n\nThis structure represents a Schrodinger PDE with non-polynomial potentials.\n\nFields:\n\nboundaries::NTuple{N,NTuple{2,Tv}}: Boundaries of the cartesian domain where you want to solve the PDE.\ncomponents::MComp: Components of the Schrodinger PDE\nF::Potential: Non-polynomical potential\nT::Tv: Final time\n\n\n\n\n\n","category":"type"},{"location":"Usage/construction/","page":"How to define a problem","title":"How to define a problem","text":"note: Note\nYou must pass the set of components as a tuple to the constructor.","category":"page"},{"location":"Usage/construction/","page":"How to define a problem","title":"How to define a problem","text":"warning: Important\nYou must define your functions in vectorized form where your components or variables are represented by columns. This means that your functions must be able to accept and return arrays.","category":"page"},{"location":"Usage/construction/#Example","page":"How to define a problem","title":"Example","text":"","category":"section"},{"location":"Usage/construction/","page":"How to define a problem","title":"How to define a problem","text":"\nusing SchrodingerToolkit\n\nconst α₁ = 1.0 \nconst α₂ = 1.0 \nconst σ₁₁ = 1.0 \nconst σ₂₂ = 1.0     \nconst σ₁₂ = 2.0/3.0\nconst σ₂₁ = σ₁₂\n\nconst T = 40.0\n\nconst Ω = (-8.0,8.0) #Domain at each dimension\n\nfunction f₁(x) # DF/Dx₁\n    @. @views -σ₁₁*x[:,1] - σ₁₂*x[:,2]\nend\n\nfunction f₂(x) # DF/Dx₂ \n    @. @views -σ₂₁*x[:,1] - σ₂₂*x[:,2]\nend\n\nfunction F(x) # F\n    @. @views -0.5*(σ₁₁*x[:,1]^2 + σ₂₂*x[:,2]^2) - σ₁₂*x[:,1]*x[:,2]\nend\n\nfunction ψ₁(x) # ψ₁ initial condition for component 1\n    @. @views 1/sqrt(pi)*exp(-(x[:,1]-2.0)^2-(x[:,2]-2.0)^2)\nend\n\nfunction ψ₂(x) # ψ₂ initial condition for component 2\n    @. @views 1/sqrt(pi)*exp(-(x[:,1]+2.0)^2-(x[:,2]+2.0)^2)\nend\n\n# Polynomial potential helper function to elude catastrophic cancellation.\n#x: \n#-0.5r*σ₁₁ - 0.5x*σ₁₁ - y*σ₁₂\n#y: \n#-0.5r*σ₂₂ - x*σ₁₂ - 0.5y*σ₂₂\nfunction N(prev,next,idx)\n    if idx == 1\n        return @. @views -0.5*σ₁₁*next-0.5*σ₁₁*prev[:,1]-σ₁₂*prev[:,2]\n    else\n        return @. @views -0.5*σ₂₂*next-σ₁₂*prev[:,1]-0.5*σ₂₂*prev[:,2]\n    end\nend\n\n# Define the components\n\nC1 = SchrodingerPDEComponent(f₁, ψ₁, α₁)\nC2 = SchrodingerPDEComponent(f₂, ψ₂, α₂)\n\n# Define the Schrodinger equation\n\nPDE = SchrodingerPDEPolynomial((Ω,Ω),(C1,C2), F, N, T)","category":"page"},{"location":"Theory/DFP/","page":"DFP","title":"DFP","text":"In the journey of explore how to improve parallelism we need to learn the theory behind how to discretize the equation.","category":"page"},{"location":"API/","page":"Index","title":"Index","text":"","category":"page"},{"location":"about/#Why-did-I-create-this-package?","page":"About","title":"Why did I create this package?","text":"","category":"section"},{"location":"about/","page":"About","title":"About","text":"I am pursuing a Master's degree in Scientific Computing and aim to become proficient in developing numerical methods for solving PDEs. This package is part of my research work, focusing on numerical methods for solving nonlinear Schrödinger equations. Additionally, I am interested in parallelizing these methods using GPUs. This work represents a partially successful attempt to parallelize the solution to the aforementioned problem using GPUs. The idea behind this arose from the need to perform larger simulations in a reasonable amount of time with specialized hardware.","category":"page"},{"location":"Usage/methods/#How-to-choose-a-method","page":"Method selection","title":"How to choose a method","text":"","category":"section"},{"location":"Usage/methods/","page":"Method selection","title":"Method selection","text":"Here is a description of available methods and characteristics of each method.","category":"page"},{"location":"Usage/methods/","page":"Method selection","title":"Method selection","text":"| Method | Solve CNLS | Solve CGPE | Solve CGPE with J | |––––|––––––|––––––|–––––––––-|","category":"page"},{"location":"Theory/Problem/","page":"Problem","title":"Problem","text":"Let Omega be a Cartesian region in mathbbR^m with m=123. We are interested in get an approximation of the complex field Psi Omega times (0T longrightarrow mathbbC^N satisfying the following system of non linear equations in dimensionless form:","category":"page"},{"location":"Theory/Problem/","page":"Problem","title":"Problem","text":"    i Psi_t = D Delta Psi + mathcalV(mathbfx) odot Psi+mathcalJ(Psi)","category":"page"},{"location":"Theory/Problem/","page":"Problem","title":"Problem","text":"where mathbfx = (x_1cdotsx_m), Psi^2=left( psi_1^2cdotspsi_2^2 right), D=diag(d_i) is a mathbbR^Ntimes N diagonal matrix with positive dispersive coefficients, odot is the Hadamard or element-wise product, F mathbbR^N longrightarrow mathbbR, mathcalV Omega longrightarrow mathbbR^N represents an external trapping potential. Finally, the linear functional mathcalJ mathbbC^N longrightarrow mathbbC^N models the internal atomic Josephson junction, and takes the form mathcalJ(Psi)_n = Gammasum_j=1jneq n^N psi_j, where Gamma is a real coefficient","category":"page"},{"location":"API/API/","page":"Types","title":"Types","text":"CurrentModule = SchrodingerToolkit","category":"page"},{"location":"API/API/","page":"Types","title":"Types","text":"Modules = [SchrodingerToolkit]","category":"page"},{"location":"API/API/#SchrodingerToolkit.AbstractBackend","page":"Types","title":"SchrodingerToolkit.AbstractBackend","text":"Abstract type for our available backends\n\n\n\n\n\n","category":"type"},{"location":"API/API/#SchrodingerToolkit.AbstractRuntimeStats","page":"Types","title":"SchrodingerToolkit.AbstractRuntimeStats","text":"AbstractRuntimeStats{IntType,FloatType,IntArrayType,FloatArrayType}\n\nThis abstract type provides basic tracking for runtime analysis of PDE simulation.\n\nFunctions that you need to implement your own Stats type:\n\nlength(Stats): Current number of taken samples.\nislog(Stats): Returns true if the Stats is logging problem related data.\nislocked(Stats): Returns true if the Stats is locked meaning that you can not modify it. This is used to prevent data corruption after deserialization.\nislog_solver_info(Stats): Returns true if the Stats is logging solver related data.\nislog_system_total_mass(Stats): Returns true if the Stats is logging the total mass of the system.\nislog_component_update_steps(Stats): Returns true if the Stats is logging the number of times that the components are updated.\ninitialize_stats(::Type{FloatVectorType}, ::Type{IntVectorType},ncomponents,log_freq,time_steps,islog_solver_info::Bool): Initialize the memory underlying Stats type. \nstartup_stats!(Stats,start_mass,start_energy): Initialize the mass and energy at time step 0. This is usally stored at the last index of the memory.\nupdate_mass!(Stats,mass,index): Update the mass at time step index.\nupdate_energy!(Stats,energy,index): Update the energy at time step index.\nadvance_iteration!(Stats): Move from sample  n  to  n+1.\nserialize(Stats,path): Serialize the Stats type to a file.\ndeserialize(::Type{Stats},path): Deserialize the Stats type from a file. The type here is for dispatching purposes.\nsystem_mass(Stats,component_idx,index): Get the mass at component_idx in time step index.\nsystem_mass(Stats,component_idx): Get the full internal mass vector at component_idx.\nsystem_energy(Stats,index): Get the energy at time step index.\nsystem_energy(Stats): Get the full internal energy vector.\nstart_mass(Stats): Get the mass for all components at time step 0.\nstart_mass(Stats,component_idx): Get the mass at component_idx at time step 0.\nstart_energy(Stats): Get the energy at time step 0.\nget_solver_time(Stats,index): Get the solver time at time step index.\nget_solver_iterations(Stats,index): Get the solver iterations at time step index.\n\nNote 1: Any attempt to modify the Stats type after it is locked must throw an error or a warning.\n\nNote 2: In general is preferred to use CPU vectors for Stats type and taking care of the conversion to other types when needed. This is because indexing is slow and disallowed in GPU arrays.\n\nNote 3: As an API decision, to reduce boilerplate code is expected that when you intialize any method, then this structure is initialized too. This is because the Stats type is used to store incoming data from the simulation and data types are known at that moment. \n\nOptional functions:\n\nupdate_stats!(Stats,time,PDE,Grid,Mem,ItStop): For iterative solvers\nupdate_stats!(Stats,time,PDE,Grid,Mem): For direct solvers\n\nExamples\n\n\n\n\n\n","category":"type"},{"location":"API/API/#SchrodingerToolkit.AbstractSolverMethod","page":"Types","title":"SchrodingerToolkit.AbstractSolverMethod","text":"AbstractSolverMethod{RealType}\n\nThis is the abstract type for all solver methods. It is parametrized by the type of the real numbers used in the solver.\n\n# How to define a new solver method\nTo define a new solver method, you need to define a new struct that is a subtype of this abstract type. The struct must have the following fields:\n- `Grid`: The grid on which the solver will operate.\n\n# Expected initialization\nThe solver method must be initialized with the following arguments:\n- `config`: The basic configuration of the solver.\n- `grid`: The grid on which the solver will operate.\n\n# Required methods\nThe solver method must implement the following methods:\n- `step!`: Perform a single step of the solver.\n\n# Methods related to statistics\n[TODO]\n\n\n\n\n\n","category":"type"},{"location":"API/API/#SchrodingerToolkit.CPUBackend","page":"Types","title":"SchrodingerToolkit.CPUBackend","text":"This represents a CPU based backend\n\n\n\n\n\n","category":"type"},{"location":"API/API/#SchrodingerToolkit.GPUBackend","page":"Types","title":"SchrodingerToolkit.GPUBackend","text":"This represents a GPU based backend\n\n\n\n\n\n","category":"type"},{"location":"API/API/#SchrodingerToolkit.OffsetAllZero","page":"Types","title":"SchrodingerToolkit.OffsetAllZero","text":"No dimension has the zero offset\n\n\n\n\n\n","category":"type"},{"location":"API/API/#SchrodingerToolkit.OffsetNonZero","page":"Types","title":"SchrodingerToolkit.OffsetNonZero","text":"Every dimension has the zero offset\n\n\n\n\n\n","category":"type"},{"location":"API/API/#SchrodingerToolkit.OffsetUniqueZero","page":"Types","title":"SchrodingerToolkit.OffsetUniqueZero","text":"Only the first dimension has the zero offset\n\n\n\n\n\n","category":"type"},{"location":"API/API/#SchrodingerToolkit.SchrodingerPDE","page":"Types","title":"SchrodingerToolkit.SchrodingerPDE","text":"SchrodingerPDE\n\nThis is an abstract type that represents a Schrodinger PDE. This type is used to define a Schrodinger PDE structure.\n\nParameters:\n\nN::Int: Number of dimensions\nRealType: Type for Real numbers. This is used to define the internal algorithms and data structures.\n\nIs important to note, that the derived structures must handle boundary conditions, initial conditions and important parts of the PDE.\n\n\n\n\n\n","category":"type"},{"location":"API/API/#SchrodingerToolkit.SchrodingerPDEComponent","page":"Types","title":"SchrodingerToolkit.SchrodingerPDEComponent","text":"SchrodingerPDEComponent\n\nThis structure represents a component of the Schrodinger PDE. This is a simple structure that contains the necessary information to solve the Schrodinger PDE for a single component.\n\nFields:\n\nσ::Tv: Dispersion coefficient => Must be non negative\nf::Fn: ∂∇F/∂xᵢ(x) = f(x)\nψ::InitialCondition: Initial condition \nV::TrappingPotential: External trapping potential\nΓ::Γv: Josephson Junction Coefficient => In some documents this coefficient is the same for all components but I guess it can be different under some circumstances.\n\nBy default V and Γ are set to nothing but they can be set to a trapping potential and a Josephson junction coefficient respectively if you want to work with a Gross Pitaevsky PDE.\n\n\n\n\n\n","category":"type"},{"location":"API/API/#SchrodingerToolkit.SchrodingerPDENonPolynomial","page":"Types","title":"SchrodingerToolkit.SchrodingerPDENonPolynomial","text":"SchrodingerPDENonPolynomial\n\nThis structure represents a Schrodinger PDE with non-polynomial potentials.\n\nFields:\n\nboundaries::NTuple{N,NTuple{2,Tv}}: Boundaries of the cartesian domain where you want to solve the PDE.\ncomponents::MComp: Components of the Schrodinger PDE\nF::Potential: Non-polynomical potential\nT::Tv: Final time\n\n\n\n\n\n","category":"type"},{"location":"API/API/#SchrodingerToolkit.SchrodingerPDEPolynomial","page":"Types","title":"SchrodingerToolkit.SchrodingerPDEPolynomial","text":"SchrodingerPDEPolynomial\n\nThis structure represents a Schrodinger PDE with polynomical potentials.\n\nFields:\n\nboundaries::NTuple{N,NTuple{2,Tv}}: Boundaries of the cartesian domain where you want to solve the PDE.\ncomponents::MComp: Components of the Schrodinger PDE\nF::Potential: Polynomical potential\nN::Optimized: Optimized structure for polynomical potentials. Here is stored an auxiliary function without the catastrophic cancellation problem.\nT::Tv: Final time\n\n\n\n\n\n","category":"type"},{"location":"API/API/#SchrodingerToolkit.xPUBackend","page":"Types","title":"SchrodingerToolkit.xPUBackend","text":"This represents a heterogeneous based backend (Can use a mixture of CPU and GPU)\n\n\n\n\n\n","category":"type"},{"location":"API/API/#Base.eltype-Union{Tuple{Type{SchrodingerPDENonPolynomial{N, Tv, MComp, Potential}}}, Tuple{Potential}, Tuple{MComp}, Tuple{Tv}, Tuple{N}} where {N, Tv, MComp, Potential}","page":"Types","title":"Base.eltype","text":"Type of the elements for the Schrodinger PDE\n\n\n\n\n\n","category":"method"},{"location":"API/API/#Base.eltype-Union{Tuple{Type{SchrodingerPDEPolynomial{N, Tv, MComp, Potential, Optimized}}}, Tuple{Optimized}, Tuple{Potential}, Tuple{MComp}, Tuple{Tv}, Tuple{N}} where {N, Tv, MComp, Potential, Optimized}","page":"Types","title":"Base.eltype","text":"Type of the elements for the Schrodinger PDE\n\n\n\n\n\n","category":"method"},{"location":"API/API/#Base.ndims-Union{Tuple{SchrodingerPDENonPolynomial{N, Tv, MComp, Potential}}, Tuple{Potential}, Tuple{MComp}, Tuple{Tv}, Tuple{N}} where {N, Tv, MComp, Potential}","page":"Types","title":"Base.ndims","text":"Number of dimensions for the Schrodinger PDE\n\n\n\n\n\n","category":"method"},{"location":"API/API/#Base.ndims-Union{Tuple{SchrodingerPDEPolynomial{N, Tv, MComp, Potential, Optimized}}, Tuple{Optimized}, Tuple{Potential}, Tuple{MComp}, Tuple{Tv}, Tuple{N}} where {N, Tv, MComp, Potential, Optimized}","page":"Types","title":"Base.ndims","text":"Number of dimensions for the Schrodinger PDE\n\n\n\n\n\n","category":"method"},{"location":"API/API/#SchrodingerToolkit.SecondDerivativeFiniteDifferenceSchemeAssembly-Union{Tuple{T}, Tuple{V}, Tuple{T, T, T, T, T, V}} where {V<:Integer, T<:Union{Rational{V}, AbstractFloat}}","page":"Types","title":"SchrodingerToolkit.SecondDerivativeFiniteDifferenceSchemeAssembly","text":"@inline SecondDerivativeFiniteDifferenceSchemeAssembly(a::T, b::T, c::T, α::T, β::T,\n                                              order::V) where {V<:Integer,\n                                                               T<:AbstractFloatOrRational{V}}\n\nConstructs a Second Derivative Finite Difference Scheme Assembly with the given coefficients. Here you define the coefficients for the 1D case. 2D and 3D cases are constructed by Kronecker product/sum among 1D schemes for each dimension.\n\nThings to remember for 1D case\n\nA(δᵢ) = D(ψ(xᵢ)) where D = aΔ₀+bΔ₁+cΔ₂, δ is the classic second derivative operator and ψ(xᵢ) is the function to be approximated.\n\nConstraints\n\nTo provide a valid scheme, the following constraints must be satisfied:\n\na + 2 ^ ord * b + 3 ^ord * c = (ord + 1) * (ord + 2) * (α + 2 ^ ord * β) for ord = 0 2 order - 2\n1 - 2 * (α + β)  0 (Positive Definite Matrix)\n\nThose constraints are checked at construction time.\n\nArguments\n\na::T: Coefficient a\nb::T: Coefficient b\nc::T: Coefficient c\nα::T: Coefficient α\nβ::T: Coefficient β\norder::V: Order of the scheme\n\nReturns\n\nSecondDerivativeCoefficients{V,T}: Second Derivative Finite Difference Scheme Assembly\n\nReference for compact finite difference schemes\n\nCompact finite difference schemes with spectral-like resolution\n\n\n\n\n\n","category":"method"},{"location":"API/API/#SchrodingerToolkit.advance_iteration!-Union{Tuple{SchrodingerToolkit.RuntimeStats{IntType, FloatType, IntVectorType, FloatVectorType, Mass} where {IntVectorType, FloatVectorType<:(AbstractArray{FloatType}), Mass<:Tuple{Vararg{SchrodingerToolkit.ComponentMass{FloatType, FloatVectorType}}}}}, Tuple{FloatType}, Tuple{IntType}} where {IntType<:Integer, FloatType<:AbstractFloat}","page":"Types","title":"SchrodingerToolkit.advance_iteration!","text":"advance_iteration!(R::RuntimeStats{IntType,FloatType}) where {IntType<:Integer,\n                                                             FloatType<:AbstractFloat}\n\nAdvance the iteration in the stats structure.\n\n\n\n\n\n","category":"method"},{"location":"API/API/#SchrodingerToolkit.calculate_diff_step_and_solver_time-Tuple{Stats} where Stats<:SchrodingerToolkit.RuntimeStats","page":"Types","title":"SchrodingerToolkit.calculate_diff_step_and_solver_time","text":"calculate_diff_step_and_solver_time(stats)\n\nCalculate the absolute value of the difference between the time spent in the current step and the time spent in the solver.\n\nArguments\n\nstats::Stats: The stats structure.\n\n\n\n\n\n","category":"method"},{"location":"API/API/#SchrodingerToolkit.calculate_diff_system_energy-Tuple{Stats} where Stats<:SchrodingerToolkit.RuntimeStats","page":"Types","title":"SchrodingerToolkit.calculate_diff_system_energy","text":"calculate_diff_system_energy(stats)\n\nCalculate the absolute value of the difference between the system energy and the energy at time step 0.\n\nArguments\n\nstats::Stats: The stats structure.\n\n\n\n\n\n","category":"method"},{"location":"API/API/#SchrodingerToolkit.calculate_diff_system_mass-Union{Tuple{Stats}, Tuple{Stats, Any}} where Stats<:SchrodingerToolkit.RuntimeStats","page":"Types","title":"SchrodingerToolkit.calculate_diff_system_mass","text":"calculate_diff_system_mass(stats)\n\nCalculate the absolute value of the difference between the system mass and the mass at time step 0.\n\nArguments\n\nstats::Stats: The stats structure.\n\n\n\n\n\n","category":"method"},{"location":"API/API/#SchrodingerToolkit.calculate_diff_system_total_mass-Tuple{Stats} where Stats<:SchrodingerToolkit.RuntimeStats","page":"Types","title":"SchrodingerToolkit.calculate_diff_system_total_mass","text":"calculate_diff_system_total_mass(stats)\n\nCalculate the absolute value of the difference between the system total mass and the total mass at time step 0.\n\nArguments\n\nstats::Stats: The stats structure.\n\n\n\n\n\n","category":"method"},{"location":"API/API/#SchrodingerToolkit.diagram_2d-Tuple{Any, Any}","page":"Types","title":"SchrodingerToolkit.diagram_2d","text":"diagram_2d(xval, yval; xlabel = \"x - label\", ylabel = \"y - label\", xscale = identity, yscale = identity, kwargs...)\n\nCreate a 2D diagram.\n\nArguments\n\nxval: The x-values.\nyval: The y-values.\n\nKeyword Arguments\n\nxlabel::String: The x-label.\nylabel::String: The y-label.\n\nReturns\n\nfig: The figure.\naxis: The axis.\n\n\n\n\n\n","category":"method"},{"location":"API/API/#SchrodingerToolkit.diagram_axis_conf-Tuple{Any}","page":"Types","title":"SchrodingerToolkit.diagram_axis_conf","text":"diagram_axis_conf(axis; labelsize = 48, ticklabelsize = 42)\n\nConfigure the axis.\n\nArguments\n\naxis: The axis.\n\nKeyword Arguments\n\nlabelsize::Int: The size of the label.\nticklabelsize::Int: The size of the tick label.\n\n\n\n\n\n","category":"method"},{"location":"API/API/#SchrodingerToolkit.diagram_base_2d-Tuple{Any, Any, Any}","page":"Types","title":"SchrodingerToolkit.diagram_base_2d","text":"diagram_base_2d(xval, yval; xlabel = \"x - label\", ylabel = \"y - label\", kwargs...)\n\nCreate a 2D diagram with average line.\n\nArguments\n\nxval: The x-values.\nyval: The y-values.\n\nKeyword Arguments\n\nxlabel::String: The x-label.\nylabel::String: The y-label.\nkwargs...: Additional keyword arguments passed to Makie.\n\nReturns\n\nfig: The figure.\naxis: The axis.\n\n\n\n\n\n","category":"method"},{"location":"API/API/#SchrodingerToolkit.diagram_hide_conf-Tuple{Any}","page":"Types","title":"SchrodingerToolkit.diagram_hide_conf","text":"diagram_hide_conf(axis)\n\nHide the grid and minor grid lines.\n\nArguments\n\naxis: The axis.\n\n\n\n\n\n","category":"method"},{"location":"API/API/#SchrodingerToolkit.diagram_hide_env-Tuple{Any}","page":"Types","title":"SchrodingerToolkit.diagram_hide_env","text":"diagram_hide_env(axis)\n\nHide the spines and decorations.\n\nArguments\n\naxis: The axis.\n\n\n\n\n\n","category":"method"},{"location":"API/API/#SchrodingerToolkit.diagram_label_conf-Tuple{Any}","page":"Types","title":"SchrodingerToolkit.diagram_label_conf","text":"diagram_label_conf(axis; xlabel = \"x-label\", ylabel = \"y-label\", zlabel = \"z-label\")\n\nConfigure the labels.\n\nArguments\n\naxis: The axis.\n\nKeyword Arguments\n\nxlabel::String: The x-label.\nylabel::String: The y-label.\nzlabel::String: The z-label.\n\n\n\n\n\n","category":"method"},{"location":"API/API/#SchrodingerToolkit.diagram_startup-Tuple{}","page":"Types","title":"SchrodingerToolkit.diagram_startup","text":"diagram_startup(; fig_height::Int = 1000, fig_ratio = 4 / 3)\n\nCreate a figure with the specified height and ratio.\n\nKeyword Arguments\n\nfig_height::Int: The height of the figure.\nfig_ratio: The ratio of the figure.\n\nReturns\n\nfig: The figure.\n\n\n\n\n\n","category":"method"},{"location":"API/API/#SchrodingerToolkit.estimate_timesteps-Union{Tuple{PGrid}, Tuple{SPDE}, Tuple{SPDE, PGrid}} where {SPDE<:SchrodingerPDE, PGrid<:PeriodicGrid}","page":"Types","title":"SchrodingerToolkit.estimate_timesteps","text":"Estimate the number of timesteps for the Schrodinger PDE\n\n\n\n\n\n","category":"method"},{"location":"API/API/#SchrodingerToolkit.evaluate_ψ!-Union{Tuple{PGrid}, Tuple{SPDE}, Tuple{SPDE, PGrid, Any}} where {SPDE<:SchrodingerPDE, PGrid<:PeriodicGrid}","page":"Types","title":"SchrodingerToolkit.evaluate_ψ!","text":"Evaluation of the initial condition for the Schrodinger PDE where the output is stored in Container\n\n\n\n\n\n","category":"method"},{"location":"API/API/#SchrodingerToolkit.evaluate_ψ-Union{Tuple{PGrid}, Tuple{Optimized}, Tuple{Potential}, Tuple{MComp}, Tuple{Tv}, Tuple{N}, Tuple{SchrodingerPDEPolynomial{N, Tv, MComp, Potential, Optimized}, PGrid, Any}} where {N, Tv, MComp, Potential, Optimized, PGrid<:PeriodicGrid}","page":"Types","title":"SchrodingerToolkit.evaluate_ψ","text":"Evaluation of the initial condition for the Schrodinger PDE\n\n\n\n\n\n","category":"method"},{"location":"API/API/#SchrodingerToolkit.evaluate_ψ-Union{Tuple{PGrid}, Tuple{Potential}, Tuple{MComp}, Tuple{Tv}, Tuple{N}, Tuple{SchrodingerPDENonPolynomial{N, Tv, MComp, Potential}, PGrid, Any}} where {N, Tv, MComp, Potential, PGrid<:PeriodicGrid}","page":"Types","title":"SchrodingerToolkit.evaluate_ψ","text":"Evaluation of the initial condition for the Schrodinger PDE\n\n\n\n\n\n","category":"method"},{"location":"API/API/#SchrodingerToolkit.get_V-Union{Tuple{Optimized}, Tuple{Potential}, Tuple{MComp}, Tuple{Tv}, Tuple{N}, Tuple{SchrodingerPDEPolynomial{N, Tv, MComp, Potential, Optimized}, Int64}} where {N, Tv, MComp, Potential, Optimized}","page":"Types","title":"SchrodingerToolkit.get_V","text":"Trapping potential for the i-th Schrodinger PDE component\n\n\n\n\n\n","category":"method"},{"location":"API/API/#SchrodingerToolkit.get_V-Union{Tuple{Potential}, Tuple{MComp}, Tuple{Tv}, Tuple{N}, Tuple{SchrodingerPDENonPolynomial{N, Tv, MComp, Potential}, Int64}} where {N, Tv, MComp, Potential}","page":"Types","title":"SchrodingerToolkit.get_V","text":"Trapping potential for the i-th Schrodinger PDE component\n\n\n\n\n\n","category":"method"},{"location":"API/API/#SchrodingerToolkit.get_boundary-Union{Tuple{Optimized}, Tuple{Potential}, Tuple{MComp}, Tuple{Tv}, Tuple{N}, Tuple{SchrodingerPDEPolynomial{N, Tv, MComp, Potential, Optimized}, Int64}} where {N, Tv, MComp, Potential, Optimized}","page":"Types","title":"SchrodingerToolkit.get_boundary","text":"Boundary start and end point at index dimension\n\n\n\n\n\n","category":"method"},{"location":"API/API/#SchrodingerToolkit.get_boundary-Union{Tuple{Potential}, Tuple{MComp}, Tuple{Tv}, Tuple{N}, Tuple{SchrodingerPDENonPolynomial{N, Tv, MComp, Potential}, Int64}} where {N, Tv, MComp, Potential}","page":"Types","title":"SchrodingerToolkit.get_boundary","text":"Boundary start and end point at index dimension\n\n\n\n\n\n","category":"method"},{"location":"API/API/#SchrodingerToolkit.get_component-Union{Tuple{Optimized}, Tuple{Potential}, Tuple{MComp}, Tuple{Tv}, Tuple{N}, Tuple{SchrodingerPDEPolynomial{N, Tv, MComp, Potential, Optimized}, Int64}} where {N, Tv, MComp, Potential, Optimized}","page":"Types","title":"SchrodingerToolkit.get_component","text":"Obtain the component of the Schrodinger PDE at index\n\n\n\n\n\n","category":"method"},{"location":"API/API/#SchrodingerToolkit.get_component-Union{Tuple{Potential}, Tuple{MComp}, Tuple{Tv}, Tuple{N}, Tuple{SchrodingerPDENonPolynomial{N, Tv, MComp, Potential}, Int64}} where {N, Tv, MComp, Potential}","page":"Types","title":"SchrodingerToolkit.get_component","text":"Obtain the component of the Schrodinger PDE at index\n\n\n\n\n\n","category":"method"},{"location":"API/API/#SchrodingerToolkit.get_f-Union{Tuple{Optimized}, Tuple{Potential}, Tuple{MComp}, Tuple{Tv}, Tuple{N}, Tuple{SchrodingerPDEPolynomial{N, Tv, MComp, Potential, Optimized}, Int64}} where {N, Tv, MComp, Potential, Optimized}","page":"Types","title":"SchrodingerToolkit.get_f","text":"Function for the Schrodinger PDE component\n\n\n\n\n\n","category":"method"},{"location":"API/API/#SchrodingerToolkit.get_f-Union{Tuple{Potential}, Tuple{MComp}, Tuple{Tv}, Tuple{N}, Tuple{SchrodingerPDENonPolynomial{N, Tv, MComp, Potential}, Int64}} where {N, Tv, MComp, Potential}","page":"Types","title":"SchrodingerToolkit.get_f","text":"Function for the Schrodinger PDE component\n\n\n\n\n\n","category":"method"},{"location":"API/API/#SchrodingerToolkit.get_field-Union{Tuple{SchrodingerPDENonPolynomial{N, Tv, MComp, Potential}}, Tuple{Potential}, Tuple{MComp}, Tuple{Tv}, Tuple{N}} where {N, Tv, MComp, Potential}","page":"Types","title":"SchrodingerToolkit.get_field","text":"Potential for the Schrodinger PDE\n\n\n\n\n\n","category":"method"},{"location":"API/API/#SchrodingerToolkit.get_field-Union{Tuple{SchrodingerPDEPolynomial{N, Tv, MComp, Potential, Optimized}}, Tuple{Optimized}, Tuple{Potential}, Tuple{MComp}, Tuple{Tv}, Tuple{N}} where {N, Tv, MComp, Potential, Optimized}","page":"Types","title":"SchrodingerToolkit.get_field","text":"Potential for the Schrodinger PDE\n\n\n\n\n\n","category":"method"},{"location":"API/API/#SchrodingerToolkit.get_optimized-Union{Tuple{SchrodingerPDENonPolynomial{N, Tv, MComp, Potential}}, Tuple{Potential}, Tuple{MComp}, Tuple{Tv}, Tuple{N}} where {N, Tv, MComp, Potential}","page":"Types","title":"SchrodingerToolkit.get_optimized","text":"Non polynomial potentials can't be optimized so return nothing\n\n\n\n\n\n","category":"method"},{"location":"API/API/#SchrodingerToolkit.get_optimized-Union{Tuple{SchrodingerPDEPolynomial{N, Tv, MComp, Potential, Optimized}}, Tuple{Optimized}, Tuple{Potential}, Tuple{MComp}, Tuple{Tv}, Tuple{N}} where {N, Tv, MComp, Potential, Optimized}","page":"Types","title":"SchrodingerToolkit.get_optimized","text":"Simplified polynomial to evade catastrophic cancellation\n\n\n\n\n\n","category":"method"},{"location":"API/API/#SchrodingerToolkit.get_time_boundary-Union{Tuple{SchrodingerPDENonPolynomial{N, Tv, MComp, Potential}}, Tuple{Potential}, Tuple{MComp}, Tuple{Tv}, Tuple{N}} where {N, Tv, MComp, Potential}","page":"Types","title":"SchrodingerToolkit.get_time_boundary","text":"Finish time for the Schrodinger PDE\n\n\n\n\n\n","category":"method"},{"location":"API/API/#SchrodingerToolkit.get_time_boundary-Union{Tuple{SchrodingerPDEPolynomial{N, Tv, MComp, Potential, Optimized}}, Tuple{Optimized}, Tuple{Potential}, Tuple{MComp}, Tuple{Tv}, Tuple{N}} where {N, Tv, MComp, Potential, Optimized}","page":"Types","title":"SchrodingerToolkit.get_time_boundary","text":"Finish time for the Schrodinger PDE\n\n\n\n\n\n","category":"method"},{"location":"API/API/#SchrodingerToolkit.get_Γ-Union{Tuple{Optimized}, Tuple{Potential}, Tuple{MComp}, Tuple{Tv}, Tuple{N}, Tuple{SchrodingerPDEPolynomial{N, Tv, MComp, Potential, Optimized}, Int64}} where {N, Tv, MComp, Potential, Optimized}","page":"Types","title":"SchrodingerToolkit.get_Γ","text":"Josephson Junction Coefficient for the i-th Schrodinger PDE component\n\n\n\n\n\n","category":"method"},{"location":"API/API/#SchrodingerToolkit.get_Γ-Union{Tuple{Potential}, Tuple{MComp}, Tuple{Tv}, Tuple{N}, Tuple{SchrodingerPDENonPolynomial{N, Tv, MComp, Potential}, Int64}} where {N, Tv, MComp, Potential}","page":"Types","title":"SchrodingerToolkit.get_Γ","text":"Josephson Junction Coefficient for the i-th Schrodinger PDE component\n\n\n\n\n\n","category":"method"},{"location":"API/API/#SchrodingerToolkit.get_σ-Union{Tuple{Optimized}, Tuple{Potential}, Tuple{MComp}, Tuple{Tv}, Tuple{N}, Tuple{SchrodingerPDEPolynomial{N, Tv, MComp, Potential, Optimized}, Int64}} where {N, Tv, MComp, Potential, Optimized}","page":"Types","title":"SchrodingerToolkit.get_σ","text":"Dispersion coefficient for the Schrodinger PDE component at index\n\n\n\n\n\n","category":"method"},{"location":"API/API/#SchrodingerToolkit.get_σ-Union{Tuple{Potential}, Tuple{MComp}, Tuple{Tv}, Tuple{N}, Tuple{SchrodingerPDENonPolynomial{N, Tv, MComp, Potential}, Int64}} where {N, Tv, MComp, Potential}","page":"Types","title":"SchrodingerToolkit.get_σ","text":"Dispersion coefficient for the Schrodinger PDE component at index\n\n\n\n\n\n","category":"method"},{"location":"API/API/#SchrodingerToolkit.get_ψ-Union{Tuple{Optimized}, Tuple{Potential}, Tuple{MComp}, Tuple{Tv}, Tuple{N}, Tuple{SchrodingerPDEPolynomial{N, Tv, MComp, Potential, Optimized}, Int64}} where {N, Tv, MComp, Potential, Optimized}","page":"Types","title":"SchrodingerToolkit.get_ψ","text":"Initial condition for the Schrodinger PDE component\n\n\n\n\n\n","category":"method"},{"location":"API/API/#SchrodingerToolkit.get_ψ-Union{Tuple{Potential}, Tuple{MComp}, Tuple{Tv}, Tuple{N}, Tuple{SchrodingerPDENonPolynomial{N, Tv, MComp, Potential}, Int64}} where {N, Tv, MComp, Potential}","page":"Types","title":"SchrodingerToolkit.get_ψ","text":"Initial condition for the Schrodinger PDE component\n\n\n\n\n\n","category":"method"},{"location":"API/API/#SchrodingerToolkit.initialize_stats-Union{Tuple{FloatVectorType}, Tuple{IntVectorType}, Tuple{IntType}, Tuple{Type{FloatVectorType}, Type{IntVectorType}, IntType, IntType, IntType}} where {IntType, IntVectorType, FloatVectorType}","page":"Types","title":"SchrodingerToolkit.initialize_stats","text":"initialize_stats(FloatVectorType, IntVectorType, ncomponents, log_freq, time_steps;\n                 log_stats = true, log_solver_info = true,\n                 log_component_update_steps = false,\n                 log_system_total_mass = false, islocked = false)\n\nInitialize the stats structure.\n\nArguments\n\nFloatVectorType: The type of the floating point vector.\nIntVectorType: The type of the integer vector.\nncomponents: The number of components.\nlog_freq: The frequency to log the stats.\ntime_steps: The total number of time steps.\n\nOptional arguments\n\nlog_stats: Log the stats.\nlog_solver_info: Log the solver information.\nlog_component_update_steps: Log the component update steps.\nlog_system_total_mass: Log the system total mass.\nislocked: Lock the stats.\n\nReturns\n\nRuntimeStats: The stats structure.\n\n\n\n\n\n","category":"method"},{"location":"API/API/#SchrodingerToolkit.iscpu","page":"Types","title":"SchrodingerToolkit.iscpu","text":"Function to check if a backend is a CPU based backend\n\n\n\n\n\n","category":"function"},{"location":"API/API/#SchrodingerToolkit.isgpu","page":"Types","title":"SchrodingerToolkit.isgpu","text":"Function to check if a backend is a GPU based backend\n\n\n\n\n\n","category":"function"},{"location":"API/API/#SchrodingerToolkit.islocked-Tuple{SchrodingerToolkit.RuntimeStats}","page":"Types","title":"SchrodingerToolkit.islocked","text":"islocked(R::RuntimeStats)\n\nCheck if the stats are locked. This is used to check if the stats are locked and cannot be modified in any way.\n\nNote\n\nAny attempt to use or modify the Stats structure if it is locked will throw an error.\n\n\n\n\n\n","category":"method"},{"location":"API/API/#SchrodingerToolkit.islog-Tuple{SchrodingerToolkit.RuntimeStats}","page":"Types","title":"SchrodingerToolkit.islog","text":"islog(R::RuntimeStats)\n\nCheck if the stats are being logged. Note that this is different from isregistering_stats. This is used to check if the stats are being logged at the current time step.\n\n\n\n\n\n","category":"method"},{"location":"API/API/#SchrodingerToolkit.isregistering_stats-Tuple{SchrodingerToolkit.RuntimeStats}","page":"Types","title":"SchrodingerToolkit.isregistering_stats","text":"isregistering_stats(R::RuntimeStats)\n\nCheck if the stats are being registered.\n\n\n\n\n\n","category":"method"},{"location":"API/API/#SchrodingerToolkit.isxpu","page":"Types","title":"SchrodingerToolkit.isxpu","text":"Function to check if a backend is a heterogeneous based backend\n\n\n\n\n\n","category":"function"},{"location":"API/API/#SchrodingerToolkit.junction!-Union{Tuple{PDEeq}, Tuple{PDEeq, Any, Any, Any}} where PDEeq<:SchrodingerPDE","page":"Types","title":"SchrodingerToolkit.junction!","text":"junction!(SPDE::PDEeq, memory, output)\n\nCheck if the Schrodinger PDE has a Josephson Junction and return the sum of the current state if it has one.\n\n\n\n\n\n","category":"method"},{"location":"API/API/#SchrodingerToolkit.matrix_to_vector-Union{Tuple{Type{M}}, Tuple{M}} where M<:(DenseMatrix)","page":"Types","title":"SchrodingerToolkit.matrix_to_vector","text":"S = matrix_to_vector(M)\n\nReturn the dense vector storage type S related to the dense matrix storage type M.\n\n\n\n\n\n","category":"method"},{"location":"API/API/#SchrodingerToolkit.measure-Union{Tuple{PeriodicGrid{V, T, R, N}}, Tuple{N}, Tuple{R}, Tuple{T}, Tuple{V}} where {V<:Integer, T<:Real, R<:AbstractRange{T}, N}","page":"Types","title":"SchrodingerToolkit.measure","text":"measure(A::PeriodicGrid{V,T,R,N}) where {V<:Integer,T<:Real,R<:AbstractRange{T},N}\n\nReturn the measure of the grid.\n\n\n\n\n\n","category":"method"},{"location":"API/API/#SchrodingerToolkit.ncomponents-Tuple{PDEeq} where PDEeq<:SchrodingerPDE","page":"Types","title":"SchrodingerToolkit.ncomponents","text":"Number of components for the Schrodinger PDE\n\n\n\n\n\n","category":"method"},{"location":"API/API/#SchrodingerToolkit.plot_absolute_error_mass_per_component-Union{Tuple{RTStats}, Tuple{RTStats, Any, Any}} where RTStats<:SchrodingerToolkit.AbstractRuntimeStats","page":"Types","title":"SchrodingerToolkit.plot_absolute_error_mass_per_component","text":"plot_absolute_error_mass_per_component(Stats::RTStats, Grid, index; kwargs...)\n\nPlot the absolute error in the mass at each component at each time step.\n\nArguments\n\nStats::RTStats: The runtime statistics.\nGrid: The grid.\nindex: The index of the component.\nkwargs...: Additional keyword arguments passed to diagram_2d.\n\n\n\n\n\n","category":"method"},{"location":"API/API/#SchrodingerToolkit.plot_absolute_error_system_energy-Union{Tuple{RTStats}, Tuple{RTStats, Any}} where RTStats<:SchrodingerToolkit.AbstractRuntimeStats","page":"Types","title":"SchrodingerToolkit.plot_absolute_error_system_energy","text":"plot_absolute_error_system_energy(Stats::RTStats, Grid; kwargs...)\n\nPlot the absolute error in the system energy at each time step.\n\nArguments\n\nStats::RTStats: The runtime statistics.\nGrid: The grid.\nkwargs...: Additional keyword arguments passed to diagram_2d.\n\n\n\n\n\n","category":"method"},{"location":"API/API/#SchrodingerToolkit.plot_absolute_error_total_mass-Union{Tuple{RTStats}, Tuple{RTStats, Any}} where RTStats<:SchrodingerToolkit.AbstractRuntimeStats","page":"Types","title":"SchrodingerToolkit.plot_absolute_error_total_mass","text":"plot_absolute_error_total_mass(Stats::RTStats, Grid)\n\nPlot the absolute error in the total mass at each time step.\n\nArguments\n\nStats::RTStats: The runtime statistics.\nGrid: The grid.\n\n\n\n\n\n","category":"method"},{"location":"API/API/#SchrodingerToolkit.plot_component_update_steps-Union{Tuple{RTStats}, Tuple{RTStats, Any}} where RTStats<:SchrodingerToolkit.AbstractRuntimeStats","page":"Types","title":"SchrodingerToolkit.plot_component_update_steps","text":"plot_component_update_steps(Stats::RTStats, Grid; kwargs...)\n\nPlot the number of steps taken by the component update function at each time step.\n\nArguments\n\nStats::RTStats: The runtime statistics.\nGrid: The grid.\nkwargs...: Additional keyword arguments passed to diagram_base_2d.\n\n\n\n\n\n","category":"method"},{"location":"API/API/#SchrodingerToolkit.plot_execution_time-Union{Tuple{RTStats}, Tuple{RTStats, Any}} where RTStats<:SchrodingerToolkit.AbstractRuntimeStats","page":"Types","title":"SchrodingerToolkit.plot_execution_time","text":"plot_execution_time(Stats::RTStats, Grid; kwargs...)\n\nPlot the execution time at each time step.\n\nArguments\n\nStats::RTStats: The runtime statistics.\nGrid: The grid.\nkwargs...: Additional keyword arguments passed to diagram_base_2d.\n\n\n\n\n\n","category":"method"},{"location":"API/API/#SchrodingerToolkit.plot_mass_per_component-Union{Tuple{RTStats}, Tuple{RTStats, Any, Any}} where RTStats<:SchrodingerToolkit.AbstractRuntimeStats","page":"Types","title":"SchrodingerToolkit.plot_mass_per_component","text":"plot_mass_per_component(Stats::RTStats, Grid, index; kwargs...)\n\nPlot the mass at each component at each time step.\n\nArguments\n\nStats::RTStats: The runtime statistics.\nGrid: The grid.\nindex: The index of the component.\nkwargs...: Additional keyword arguments passed to diagram_2d.\n\n\n\n\n\n","category":"method"},{"location":"API/API/#SchrodingerToolkit.plot_solver_iterations-Union{Tuple{RTStats}, Tuple{RTStats, Any}} where RTStats<:SchrodingerToolkit.AbstractRuntimeStats","page":"Types","title":"SchrodingerToolkit.plot_solver_iterations","text":"plot_solver_iterations(Stats::RTStats, Grid; kwargs...)\n\nPlot the number of iterations taken by the solver at each time step.\n\nArguments\n\nStats::RTStats: The runtime statistics.\nGrid: The grid.\nkwargs...: Additional keyword arguments passed to diagram_base_2d.\n\n\n\n\n\n","category":"method"},{"location":"API/API/#SchrodingerToolkit.plot_solver_time-Union{Tuple{RTStats}, Tuple{RTStats, Any}} where RTStats<:SchrodingerToolkit.AbstractRuntimeStats","page":"Types","title":"SchrodingerToolkit.plot_solver_time","text":"plot_solver_time(Stats::RTStats, Grid; kwargs...)\n\nPlot the solver time at each time step.\n\nArguments\n\nStats::RTStats: The runtime statistics.\nGrid: The grid.\nkwargs...: Additional keyword arguments passed to diagram_base_2d.\n\n\n\n\n\n","category":"method"},{"location":"API/API/#SchrodingerToolkit.plot_systemnd-Tuple{Any, Any, Any}","page":"Types","title":"SchrodingerToolkit.plot_systemnd","text":"plot_systemnd(Memory, Grid, idx; kwargs...)\n\nPlot the system at current time step.\n\nArguments\n\nMemory: The memory struct.\nGrid: The grid.\nidx: The index of the component.\nkwargs...: Additional keyword arguments passed to Makie.\n\n\n\n\n\n","category":"method"},{"location":"API/API/#SchrodingerToolkit.plot_total_mass-Union{Tuple{RTStats}, Tuple{RTStats, Any}} where RTStats<:SchrodingerToolkit.AbstractRuntimeStats","page":"Types","title":"SchrodingerToolkit.plot_total_mass","text":"plot_total_mass(Stats::RTStats, Grid)\n\nPlot the total mass at each time step.\n\nArguments\n\nStats::RTStats: The runtime statistics.\nGrid: The grid.\n\n\n\n\n\n","category":"method"},{"location":"API/API/#SchrodingerToolkit.solver_iterations-Tuple{Stats} where Stats<:SchrodingerToolkit.RuntimeStats","page":"Types","title":"SchrodingerToolkit.solver_iterations","text":"solver_iteations(stats)\n\nGet the number of iterations performed in the solver.\n\nArguments\n\nstats::Stats: The stats structure.\n\n\n\n\n\n","category":"method"},{"location":"API/API/#SchrodingerToolkit.solver_time-Tuple{Stats} where Stats<:SchrodingerToolkit.RuntimeStats","page":"Types","title":"SchrodingerToolkit.solver_time","text":"solver_time(stats)\n\nGet the time spent in the solver.\n\nArguments\n\nstats::Stats: The stats structure.\n\n\n\n\n\n","category":"method"},{"location":"API/API/#SchrodingerToolkit.startup_stats!-Union{Tuple{Stats}, Tuple{Stats, Any, Any, Any}} where Stats<:SchrodingerToolkit.RuntimeStats","page":"Types","title":"SchrodingerToolkit.startup_stats!","text":"startup_stats!(stats::Stats, start_mass, start_energy, total_mass)\n\nInitialize the stats structure with the mass, energy and total mass at time step 0.\n\n\n\n\n\n","category":"method"},{"location":"API/API/#SchrodingerToolkit.startup_stats!-Union{Tuple{Stats}, Tuple{Stats, Any, Any}} where Stats<:SchrodingerToolkit.RuntimeStats","page":"Types","title":"SchrodingerToolkit.startup_stats!","text":"startup_stats!(stats::Stats, start_mass, start_energy)\n\nInitialize the stats structure with the mass and energy at time step 0.\n\n\n\n\n\n","category":"method"},{"location":"API/API/#SchrodingerToolkit.step!","page":"Types","title":"SchrodingerToolkit.step!","text":"With this function you can advance one step in time.\n\n    The implementation of this function is mandatory.\n\n    From the user perspective, this function should be called to advance the solution one step in time.\n\n    The expected parameters are:\n        - `method`: The method to be used to advance the solution.\n        - `memory`: The memory of the method.\n            Expectations about memory are: \n                - The memory must be allocated by the method at initialization.\n                - The memory must be updated by the method.\n                - You must provide a method called `current_state!(memory)` that allows the caller to get a reference to the current state (time step).\n                - You must provide a method called `current_state(memory)` that allows the caller to get a copy of the current state of (time step).\n        - `stats`: The statistics of the method.\n                - If you want to log statistics and you perform some kind of component wise operation then:\n                    - You must call `update_solver_info!(stats, time, niter)` to store every time spent at linear solvers.\n                - In general \n        - `PDE`: The PDE to be solved.\n        - `config`: The configuration of the solver.\n    \n    Here dispatch is used to call the correct version of step!.\n\n    The return of this function must be the time taken to advance one step in time.\n\n\n\n\n\n","category":"function"},{"location":"API/API/#SchrodingerToolkit.step_time-Tuple{Stats} where Stats<:SchrodingerToolkit.RuntimeStats","page":"Types","title":"SchrodingerToolkit.step_time","text":"step_time(stats)\n\nGet the time spent in the current step.\n\nArguments\n\nstats::Stats: The stats structure.\n\n\n\n\n\n","category":"method"},{"location":"API/API/#SchrodingerToolkit.test_if_zero","page":"Types","title":"SchrodingerToolkit.test_if_zero","text":"v = test_if_zero(V,idx)\n\nReturn true if the element at position idx of the vector V is zero.\n\n\n\n\n\n","category":"function"},{"location":"API/API/#SchrodingerToolkit.update_component!","page":"Types","title":"SchrodingerToolkit.update_component!","text":"With this function you can update a component of the problem.\n\n    The implementation of this function is suggested but not mandatory.\n\n\n\n\n\n","category":"function"},{"location":"API/API/#SchrodingerToolkit.update_component_update_steps!-Union{Tuple{Stats}, Tuple{Stats, Any}} where Stats<:SchrodingerToolkit.RuntimeStats","page":"Types","title":"SchrodingerToolkit.update_component_update_steps!","text":"update_component_update_steps!(stats, steps)\n\nUpdate the component update steps in the stats structure.\n\nArguments\n\nstats::Stats: The stats structure.\nsteps::IntType: The number of steps performed in the component update.\n\n\n\n\n\n","category":"method"},{"location":"API/API/#SchrodingerToolkit.update_mass!-Union{Tuple{Stats}, Tuple{FloatType}, Tuple{IntType}, Tuple{Stats, Any, IntType}} where {IntType<:Integer, FloatType<:AbstractFloat, Stats<:(SchrodingerToolkit.RuntimeStats{IntType, FloatType, IntVectorType, FloatVectorType, Mass} where {IntVectorType, FloatVectorType<:(AbstractArray{FloatType}), Mass<:Tuple{Vararg{SchrodingerToolkit.ComponentMass{FloatType, FloatVectorType}}}})}","page":"Types","title":"SchrodingerToolkit.update_mass!","text":"update_mass!(stats, mass, idx)\n\nUpdate the mass per component in the stats structure.\n\nArguments\n\nstats::Stats: The stats structure.\nmass::Vector{FloatType}: The mass per component.\nidx::IntType: The index to update.\n\n\n\n\n\n","category":"method"},{"location":"API/API/#SchrodingerToolkit.update_solver_info!-Union{Tuple{Stats}, Tuple{Stats, Any, Any}} where Stats<:SchrodingerToolkit.RuntimeStats","page":"Types","title":"SchrodingerToolkit.update_solver_info!","text":"update_solver_info!(stats, time, iterations)\n\nUpdate the linear solver information in the stats structure.\n\nArguments\n\nstats::Stats: The stats structure.\ntime::FloatType: The time spent in the solver.\niterations::IntType: The number of iterations performed in the solver.\n\n\n\n\n\n","category":"method"},{"location":"API/API/#SchrodingerToolkit.update_stats!-Union{Tuple{MemType}, Tuple{Stats}, Tuple{Stats, MemType, Any, Any, Any}} where {Stats<:SchrodingerToolkit.RuntimeStats, MemType<:AbstractMemory}","page":"Types","title":"SchrodingerToolkit.update_stats!","text":"update_stats!(stats, memory, grid, PDE, work_timer)\n\nUpdate the stats structure with the current time, mass per component, system energy and total mass.\n\nArguments\n\nstats::Stats: The stats structure.\nmemory: The memory structure.\ngrid: The grid structure.\nPDE: The PDE structure.\nwork_timer: The timer for the work done in the current step.\n\nSide effects\n\nAdvances the iteration in the stats structure no matter if the stats are being logged or not. \n\nThis is to keep the stats structure consistent with the simulation.  For that reason is important to call this function at the end of the simulation step.\n\n\n\n\n\n","category":"method"},{"location":"API/API/#SchrodingerToolkit.update_stats!-Union{Tuple{Stats}, Tuple{Stats, Any, Any, Any}} where Stats<:SchrodingerToolkit.RuntimeStats","page":"Types","title":"SchrodingerToolkit.update_stats!","text":"update_stats!(stats, step_time, mass_per_component, sys_energy)\n\nUpdate the stats structure with the current time, mass per component and system energy.\n\nArguments\n\nstats::Stats: The stats structure.\nstep_time::FloatType: Amount of time spent in the current step.\nmass_per_component: The mass per component.\nsys_energy::FloatType: The system energy.\n\n\n\n\n\n","category":"method"},{"location":"API/API/#SchrodingerToolkit.update_stats!-Union{Tuple{Stats}, Tuple{Stats, Vararg{Any, 4}}} where Stats<:SchrodingerToolkit.RuntimeStats","page":"Types","title":"SchrodingerToolkit.update_stats!","text":"update_stats!(stats, step_time, mass_per_component, sys_energy, total_mass)\n\nUpdate the stats structure with the current time, mass per component, system energy and total mass.\n\nArguments\n\nstats::Stats: The stats structure.\nstep_time::FloatType: Amount of time spent in the current step.\nmass_per_component: The mass per component.\nsys_energy::FloatType: The system energy.\ntotal_mass::FloatType: The total mass.\n\n\n\n\n\n","category":"method"},{"location":"API/API/#SchrodingerToolkit.update_system_energy!-Union{Tuple{Stats}, Tuple{FloatType}, Tuple{IntType}, Tuple{Stats, FloatType, IntType}} where {IntType<:Integer, FloatType<:AbstractFloat, Stats<:(SchrodingerToolkit.RuntimeStats{IntType, FloatType, IntVectorType, FloatVectorType, Mass} where {IntVectorType, FloatVectorType<:(AbstractArray{FloatType}), Mass<:Tuple{Vararg{SchrodingerToolkit.ComponentMass{FloatType, FloatVectorType}}}})}","page":"Types","title":"SchrodingerToolkit.update_system_energy!","text":"update_system_energy!(stats, energy, idx)\n\nUpdate the system energy in the stats structure.\n\nArguments\n\nstats::Stats: The stats structure.\nenergy::FloatType: The energy.\nidx::IntType: The index to update.\n\n\n\n\n\n","category":"method"},{"location":"API/API/#SchrodingerToolkit.update_system_total_mass!-Union{Tuple{Stats}, Tuple{FloatType}, Tuple{IntType}, Tuple{Stats, FloatType, IntType}} where {IntType<:Integer, FloatType<:AbstractFloat, Stats<:(SchrodingerToolkit.RuntimeStats{IntType, FloatType, IntVectorType, FloatVectorType, Mass} where {IntVectorType, FloatVectorType<:(AbstractArray{FloatType}), Mass<:Tuple{Vararg{SchrodingerToolkit.ComponentMass{FloatType, FloatVectorType}}}})}","page":"Types","title":"SchrodingerToolkit.update_system_total_mass!","text":"update_system_total_mass!(stats, total_mass, idx)\n\nUpdate the system total mass in the stats structure.\n\nArguments\n\nstats::Stats: The stats structure.\ntotal_mass::FloatType: The total mass.\nidx::IntType: The index to update.\n\n\n\n\n\n","category":"method"},{"location":"API/API/#SchrodingerToolkit.vcanonical","page":"Types","title":"SchrodingerToolkit.vcanonical","text":"v = vcanonical(S, n, idx)\n\nCreate a vector of storage type S of length n where the position idx is one and any other position is zero.\n\n\n\n\n\n","category":"function"},{"location":"API/API/#SchrodingerToolkit.vfirst","page":"Types","title":"SchrodingerToolkit.vfirst","text":"v = vfirst(V)\n\nReturn the first element of the vector V.\n\n\n\n\n\n","category":"function"},{"location":"API/API/#SchrodingerToolkit.vlast","page":"Types","title":"SchrodingerToolkit.vlast","text":"v = vlast(V)\n\nReturn the last element of the vector V.\n\n\n\n\n\n","category":"function"},{"location":"API/API/#SchrodingerToolkit.vones-Tuple{Any, Any}","page":"Types","title":"SchrodingerToolkit.vones","text":"v = vones(S, n)\n\nCreate a vector of storage type S of length n only composed of one.\n\n\n\n\n\n","category":"method"},{"location":"API/API/#SchrodingerToolkit.vseq-Tuple{Any, Any}","page":"Types","title":"SchrodingerToolkit.vseq","text":"v = vseq(S, n)\n\nCreate a vector of storage type S of length n where the position i is i.\n\n\n\n\n\n","category":"method"},{"location":"API/API/#SchrodingerToolkit.vundef-Tuple{Any, Any}","page":"Types","title":"SchrodingerToolkit.vundef","text":"v = vundef(S, n)\n\nCreate an uninitialized vector of storage type S of length n.\n\n\n\n\n\n","category":"method"},{"location":"API/API/#SchrodingerToolkit.vzeros-Tuple{Any, Any}","page":"Types","title":"SchrodingerToolkit.vzeros","text":"v = vzeros(S, n)\n\nCreate a vector of storage type S of length n only composed of zero.\n\n\n\n\n\n","category":"method"},{"location":"Extensions/fdschemes/#How-to-add-a-new-finite-difference-scheme","page":"Adding a new finite difference scheme","title":"How to add a new finite difference scheme","text":"","category":"section"},{"location":"Extensions/fdschemes/","page":"Adding a new finite difference scheme","title":"Adding a new finite difference scheme","text":"SecondDerivativeFiniteDifferenceSchemeAssembly","category":"page"},{"location":"Usage/backend/","page":"Backend selection","title":"Backend selection","text":"This library allows you to use CPU, GPU and xPU backends for your computations. You need to specify what backend you want at setup time.","category":"page"},{"location":"Usage/backend/#Available-backends","page":"Backend selection","title":"Available backends","text":"","category":"section"},{"location":"Usage/backend/","page":"Backend selection","title":"Backend selection","text":"CPU: CPUBackend{IntType,FloatType}\nGPU: GPUBackend{IntType,FloatType}\nxPU: xPUBackend{IntType,FloatType}","category":"page"},{"location":"Usage/backend/","page":"Backend selection","title":"Backend selection","text":"where IntType and FloatType are the integer and floating point types you want to use. For example, CPUBackend{Int32,Float32} will use 32-bit integers and 32-bit floating point numbers on the CPU.","category":"page"},{"location":"Usage/backend/#Usage","page":"Backend selection","title":"Usage","text":"","category":"section"},{"location":"Usage/backend/","page":"Backend selection","title":"Backend selection","text":"    using SchrodingerToolkit\n\n    # Use the CPU backend\n    backend = CPUBackend{Int32,Float32} # Note that we are using the type and not the instance.\n    ...\n    SolverParameters(backend, 2, (:ord4, :ord4), :tord2_1_1) # Simply pass the backend to the SolverParameters constructor.\n    ...","category":"page"},{"location":"Usage/backend/","page":"Backend selection","title":"Backend selection","text":"If for some reason you're using a method that isn't supported by the backend you've chosen, you'll get an error message telling you so.","category":"page"},{"location":"#[SchrodingerToolkit](https://github.com/walexaindre/SchrodingerToolkit.jl)","page":"Package Overview","title":"SchrodingerToolkit","text":"","category":"section"},{"location":"","page":"Package Overview","title":"Package Overview","text":"This package is designed to solve and develop algorithms for solving certain classes of coupled nonlinear Schrödinger partial differential equations (PDEs). Specifically, we are focused on addressing the following general problem in dimensionless form:","category":"page"},{"location":"","page":"Package Overview","title":"Package Overview","text":"    i Psi_t = -D Delta Psi + mathcalV(mathbfx) odot Psi+ nabla F(Psi^2) odot Psi + mathcalJ(Psi)","category":"page"},{"location":"","page":"Package Overview","title":"Package Overview","text":"Where: ","category":"page"},{"location":"","page":"Package Overview","title":"Package Overview","text":"The expected domain of the problem is a bounded Cartesian domain Omega from mathbbR^d with d=123.\nThe boundary conditions are periodic.\nmathbfx is a vector in the space domain of the problem. Where mathbfx = (x_1 x_2 ldots x_d).\nPsi Omega times (0T longrightarrow mathbbC^N with Psi = (psi_1 psi_2 ldots psi_N) is a complex vector of size N. Here, N is the number of components of the system with N1.\nPsi^2 = (psi_1^2psi_2^2dotspsi_n^2 ) represents the vector formed by the squared norm of each component of Psi.\nD= diag(d_i) is a mathbbR^Ntimes N diagonal matrix with positive dispersive coefficients.\nmathcalVOmega longrightarrow mathbbR^N is an external trapping potential.\nodot denotes the Hadamard product.\nFmathbbR^N longrightarrow mathbbR is a function which models the strength of intra- and inter-species interactions.\nmathcalJmathbbC^N longrightarrow mathbbC^N models the internal Josephson junction. This Josephson junction takes the form mathcalJ(Psi)_n= Gamma displaystylesum_jneq n^N psi_j where Gamma is a real coefficient. ","category":"page"},{"location":"#What-can-you-expect-from-this-package?","page":"Package Overview","title":"What can you expect from this package?","text":"","category":"section"},{"location":"","page":"Package Overview","title":"Package Overview","text":"This package is designed to solve the aforementioned problem using a variety of numerical methods. It is modular, allowing users to easily swap out different components of the solution. Additionally, the package is extensible, enabling users to add new numerical methods with ease.","category":"page"},{"location":"#Important-usage-considerations","page":"Package Overview","title":"Important usage considerations","text":"","category":"section"},{"location":"","page":"Package Overview","title":"Package Overview","text":"This package is designed as a research tool. As such, it may not be as fast or as stable as other packages. However, it is intended to be flexible and easy to use, allowing users to quickly prototype new algorithms and test new ideas.","category":"page"},{"location":"#References","page":"Package Overview","title":"References","text":"","category":"section"},{"location":"","page":"Package Overview","title":"Package Overview","text":"For more information about the methods used here you can check the following references:","category":"page"},{"location":"","page":"Package Overview","title":"Package Overview","text":"A conservative splitting high-order finite difference method for coupled Gross–Pitaevskii equations in 2D\nFinite-difference conservative method for a class of non linear Schrödinger systems\nFinite-difference solutions of a non-linear Schrödinger equation\nStructure preserving Field directional splitting difference methods for nonlinear Schrödinger systems\nCompact finite difference schemes with spectral-like resolution","category":"page"}]
}
